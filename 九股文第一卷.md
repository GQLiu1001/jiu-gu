# Java

## java语言的特点

1. “一次编写，到处运行”。Java编译器将源代码编译成字节码（bytecode），该字节码可以在任何安装了Java虚拟机（JVM）的系统上运行。
2. 面向对象。Java是一门严格的面向对象编程语言，几乎一切都是对象。面向对象编程（OOP）（Object Oriented Program）代码更易于维护和复用，OOP的三大特性：继承、封装、多态。
3. 内存管理。Java拥有自己的GC（Garbage Collection）机制，自动管理内存和回收不再使用的对象。开发者不再需要手动管理内存，从而减少内存泄露等问题。

java最突出的特点：面向对象

面向对象（Object-Oriented Programming, OOP）是一种编程思想，它通过**模拟现实世界中的对象**来组织和管理代码。核心是将**数据和**操作数据的**方法绑定在一起**，形成“对象”，然后通过对象之间的交互来完成程序功能。以下是简单理解面向对象的三个基本特性：封装、继承和多态。

 **封装 (Encapsulation)：**

封装就是把对象的属性（数据）和行为（方法）打包在一起，对外隐藏细节，只暴露必要的接口。

 **继承 (Inheritance)**

继承允许一个类（子类）继承另一个类（父类）的属性和方法，复用代码并扩展功能。

 **多态 (Polymorphism)**

多态是指同一个接口或方法，在不同对象上有不同的实现方式。多态可以提高代码的扩展性和复用性，分为编译时多态（重载）和运行时多态（重写）。

**编译时多态（重载）**：方法重载是指**同一类中**可以有多个同名方它们具有不同的参数列表（参数类型、数量或顺序不同）。虽然方法名相同，但根据传入的参数不同，编译器会在编译时确定调用哪个方法。

**运行时多态（重写）**：方法重写（Method Overriding）**子类重写父类**的方法，父类引用指向子类对象时，运行时根据实际对象类型决定调用哪个方法。如 父类 Animal 定义了 sound() 方法，子类 Dog 和 Cat 重写它。

**接口多态（Interface Polymorphism）：**多个类实现同一个接口，接口类型的引用可以指向任意实现类的对象，调用时执行具体实现。

## java程序的开始：JVM

java文件的运行：在编写完java代码后将其保存到后缀名为`.java`的文件中，再由`JDK`中的`javac`编译器编译成字节码，保存在`.class`后缀名的文件中，字节码会运行在`JDK`中的`JVM`上，`JVM`是Java运行的核心，会将字节码成本地机器码来执行。

java的JDK：一个JDK 包含了 编译器（`javac`）、调试器、开发工具、JRE（java runtime environment）。

JDK中的JRE：包含了类加载器、java类库以及`JVM` 。

java的解释性和编译性：不同于编译性语言c/cpp一次性全部编译成机器码，java首先利用编译器`javac`将其编译成字节码，这体现了java语言的编译性。而编译后的字节码是不能直接在操作系统上运行的，需要由JVM来执行。JVM 最初可以逐条解释执行字节码指令，将其翻译成对应操作系统的机器码，这体现了 Java 语言的解释性。为了提升性能，JVM 还会使用 `JIT (Just-In-Time Compilation)` 即时编译技术，在程序运行时将频繁执行的“热点代码直接编译成本地机器码。这些被 JIT 编译后的代码后续会直接以本地机器码的形式执行，从而大大提高了运行效率。因此，Java 是一种结合了编译特性和解释特性的语言。

当写完整个java代码后，发生的事情：

......进入JVM后：JVM管理的内存空间可以分为两类

第一类是线程共享区域：

- 堆（heap）是内存中最大的一块也是GC的主要区域，主要存放对象实例和数组。所有线程都可访问堆中的实例。堆主要分为 新生代（Eden区(占大部分默认8/10) -> Survivor0区 -> Survivor1区）（默认1/3区域） 老年代 （默认2/3区域）
- 方法区主要存被JVM所加载的类信息、常量、静态变量、JIT编译后的代码缓存等。注意：永久代(JDK8移除)/元空间（使用的是本地内存）是方法区的实现。

第二类是线程私有区域：

- 栈（stack）每个方法在执行的时候都会创建一个栈帧的结构，记录局部变量表、操作数栈、动态链接、方法出口等信息。
- 本地方法栈 为虚拟机用到的本地方法服务。
- 程序计数器 字节码行号指示器。

```java
public class Dog{
    private int age;
    private String name;
    
    public Dog(int age ,String name){
        //this指的是调用此方法的实例 也就是dog1 把4赋值给dog1的age
        this.age = age;
        this.name = name;
    }
    public void eat(){
        System.out.println("eat");
    }
}

public class Main{
    public static void main(String[] args){
        Dog dog1 = new Dog(4,"doo");
        String a = "dog1";
        int b = 3;
        //发生了自动装箱
        //Double c = Double.valueOf(3.0);
        Double c = 3.0;
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
    }
}
```

堆：

- `Dog` 对象实例 (包含原始类型 `age` 的值 `4`，和指向 `"doo"` String 对象的引用 `name`)。

- String 对象 `"doo"` (通常在字符串常量池)。

- String 对象 `"dog1"` (通常在字符串常量池)。

- `Double` 对象实例 (包装了 `double` 值 `3.0`，由自动装箱产生)。

栈：

- 局部变量 `dog1`: 存储 `Dog` 对象在堆上的内存地址。
- 局部变量 `a`: 存储 `"dog1"` String 对象在堆上的内存地址。
- 局部变量 `b`: 直接存储原始类型 `int` 的值 `3`。
- 局部变量 `c`: 存储 `Double` 对象在堆上的内存地址。

从中可以看到Java堆是JVM中内存占比最大的区域，用于存放所有对象实例和数组，因此是垃圾收集器（GC）的主要工作区域。GC的核心策略是基于可达性分析：从GC Roots（一组必须存活的引用）出发，遍历并标记所有可达的对象。对于那些在分析后被确定为不可达的对象，如果它们覆盖了`finalize()`方法且该方法尚未被执行，这些对象会被放入一个特定的队列，由一个低优先级的Finalizer线程去调用它们的`finalize()`方法（这给了对象一次“复活”的机会，但不推荐依赖此机制）；如果对象没有覆盖`finalize()`方法，或者其`finalize()`方法已经被调用过，并且在`finalize()`执行后仍然不可达，那么这些对象就会在后续的清理阶段被GC回收内存。

相对地，在GC中存活下来的对象则会经历一个“晋升”的过程：新创建的对象通常首先被分配在新生代的Eden区。当Eden区满触发Minor GC后，存活的对象会被复制到Survivor区（S0或S1中的一个），并且对象的年龄会增加。对象在Survivor区之间经历多次Minor GC（通常是15次，可配置）后仍然存活，就会被晋升到老年代。需要特别明确的是，**Java对象实例并不会被转移到永久代（PermGen，存在于JDK 7及之前版本）或元空间（Metaspace，从JDK 8开始使用）中**；这些区域主要负责存储类的元数据信息（如类结构、方法、字段）、常量池、静态变量以及即时编译器编译后的代码等，而非程序运行时动态创建的对象实例本身。

而JVM的GC分类可以分为以下三种：

- Minor GC 新生代回收 指发生在新生代（Young Generation）的垃圾收集动作。新生代通常包括Eden区和两个Survivor区（S0和S1）。通常是当Eden区满时触发。 Minor GC 非常频繁，回收速度相对较快，因为新生代中的对象大多是“朝生夕死”的。它通常会引发较短的“Stop-the-World”（STW，应用线程暂停）。新生代主要使用“复制”（Copying）算法。
- Major GC 老年代回收 指发生在老年代（Old Generation/Tenured Generation）的垃圾收集动作。通常是老年代空间不足时，或者由一些策略（如空间分配担保失败）触发。Major GC 的频率通常比 Minor GC 低，但执行时间通常会更长，STW时间也可能更长。
- Full GC 整堆回收 当老年代空间不足或者元空间等不足的时候。 Full GC 是所有GC类型中速度最慢的，STW时间最长，对应用程序的性能影响最大。应尽量避免或减少Full GC的发生。

当前java版本默认使用的垃圾收集器为G1 (Garbage-First) Collector 一种服务器端的垃圾收集器，面向大内存（通常4GB以上）应用，目标是在可控的停顿时间内实现高吞吐量。基于“**标记-整理**”（Region内部）和整体上的“复制”（Region之间）。采用分代和Region化（将堆划分为多个大小相等的独立区域）的思路。大部分工作可以并发执行，STW时间相对可预测。

除了G1垃圾收集器还有

Serial GC (串行收集器)：对新生代采用复制算法，在进行垃圾收集时必须STW并由单个GC线程完成收集工作。对老年代采用标记-整理算法，同样STW以及单个线程工作。单核情况下简单高效但是STW时间较长。

以及Parallel GC / Parallel Scavenge (并行收集器 / 吞吐量优先收集器)：新生代采取复制算法，与串行收集器不同，它会调用多个GC线程，缩短STW时间。老年代采取标记-整理算法，同样多个GC线程并行。多核CPU吞吐量高。

至于GC的算法的进化主要分成了以下三类：

1. 复制算法：将内存分为两块，一块快要满了后将内存复制到另外一块上并把原来的内存块清除，很明显空间利用不足。注意优点有不会产生内存碎片化。
2. 标记-清除算法：分为标记和清除两个阶段，可达性分析标记要被回收的部分再清除，很明显内存碎片化和效率低。
3. 标记-整理算法：标记后不先清理，会将存活对象移到内存另一端再清理掉剩余部分，很明显解决了内存碎片化但是效率低。

接下来就是JVM中的类加载机制：

类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括以下 7 个阶段：

加载 -》 验证 -》 准备 -》 解析 -》 初始化 -》 使用 -》 卸载 or

加载 -》 链接 -》 初始化 -》 使用 -》 卸载

- 加载：java将字节码读入JVM中。
- 链接：
  - 验证：JVM检查字节码合规性。
  - 准备：创建并对类变量（static修饰）赋默认初始值，分配内存空间。
  - 解析：将常量池中的符号引用，替换为直接引用。
- 初始化：实现类初始化的代码逻辑如静态字段赋值或者执行静态初始化块内的逻辑。

当一个类加载请求发出后，会由类加载器来加载，类加载器主要分为：

启动类加载器（java核心库） 《- 扩展类加载器（java扩展jar包类库） 《- 应用程序加载器（用户类路径类库） 《- 用户自定义类加载器（自定义类加载）

JVM的类加载器有一个特殊机制：双亲委派机制：其核心机制是：当一个类加载器收到类加载请求时，他不会首先自己去加载这个类，而是委派父加载器去完成，因此最终会被传达到顶层的启动类加载器，只有父加载器无法负担时才会由子加载器加载。

而这个双亲委派机制可以有效地达到以下几个作用：

1. 保证类的唯一性，避免了不同加载器加载重复类的情况，保证类库统一性。
2. 保证安全性，启动类加载器只加载信任类路径的类，java核心类不会有安全风险。
3. 隔离性，各个加载器加载自身的类加载请求，保证职责清晰。

## java的基本语法

### java中的数据类型家族

主要分为两类：

- 基本数据类型：byte(8位) char(16位) boolean short(16位) int(32位) long(64位) float(32位) double(64位)  （注意：取值范围-2^(n-1)~2^(n-1)-1）
- 引用数据类型：类 接口 数组

java中的数据类型之间也存在转换关系：

- 自动类型转换：目标范围大时，自动转换 。
- 强制类型转换：目标范围小时，强制转换可能出现数据丢失溢出问题。
- 字符串转换：Java提供了将字符串String类型转换为其他数据类型的方法，比如`Integer.parseInt()`
- 数值之间的转换：可以将整形转换为字符型等通过包装类实现。

java除了提供数据类型之间的转换，也提供了对象之间的转换。

- 向上转换：子类转为父类，会进行自动转换。向下转换：需要强制转换。注意需要确保对象实际类型匹配。

以及包装类与基本类型的转换：

- 装箱：基本类型转为包装类。
- 拆箱：包装类转为基本类型。

为什么会有包装类呢？

比如Integer对应是int类型的包装类，就是把int类型包装成**Object**对象，对象封装有很多好处，**可以把属性也就是数据跟处理这些数据的方法结合在一起**，比如Integer就有parseInt()等方法来专门处理int型相关的数据。

另一个非常重要的原因就是**在Java中绝大部分方法或类都是用来处理类类型对象的**，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。以及在Java中，泛型只能使用引用类型，而不能使用基本类型。

对于java中的BigDecimal类和Double类：

Double 在处理浮点数时存在精度丢失的问题，而 BigDecimal 可以提供任意精度的精确计算。Double 是浮点数，而BigDecimal 直接以十进制运算，结果精确无误差。

java中为了提升效率性能有缓存池的存在：

- String 字符串常量池 如果后续有相同字面量的String会直接引用池中已有对象。
- Integer等 包装类常量池 为减少自动装箱拆箱中创建对象的开销 其中如Integer池：默认缓存 -127~128之间的Integer对象。
- BigDecimal常量池
- 枚举类常量池

### java中的高频关键字家族

- abstract：
  - 修饰类时，即为抽象类，特点是可以包含抽象方法也可以包含具体方法。
  - 修饰方法时，此方法为抽象方法，只有方法声明没有方法体，必须在非抽象子类中被重写实现。
- final：
  - 修饰类时表示这个类不能被继承，是最终的实现。
  - 修饰基本数据类型变量时表示变为常量，一旦赋值不可改变。修饰引用类型变量时其引用一旦指向一个对象后就不能再指向其他对象，但该引用所指向的对象内容是可以修改的（除非对象本身也是不可变的，如`String`）。
  - 修饰方法禁止子类重写方法，不能更改其逻辑。
- static：可以修饰方法和变量。
  - 修饰变量时可以看作为全局的共享变量，可以直接通过类名访问，且随着类的生命周期存在。
  - 修饰方法时，可以直接类名调用，不用创建对象，且只能访问静态成员（包括静态字段和静态方法）。
- this：`this` 关键字是对**当前对象实例**的引用。也就是说，`this` 指向调用该方法或构造器的那个对象。
  - 在类的构造时使用`this`即区分成员变量和局部变量。
  - 在类的方法中使用`this`即调用当前类中的其他方法。
- super：是在子类中用于访问父类成员的关键字。可以调用父类的构造器以及访问父类成员。
- synchronized：
  - 在代码块中表示上可重入锁，线程安全。
  - 在方法上表示同步方法，线程安全。

### java中的泛型家族

泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。

泛型的主要目的是在编译时提供更强的类型检查，**从而**避免了在运行时因类型不匹配而导致类型转换异常（`ClassCastException`）。虽然大部分类型信息被擦除，但编译器会插入必要的类型转换并利用桥接方法等技术来保证类型安全。

泛型中的extends与super：

- **Producer Extends (生产者使用 `extends`)**: 如果你的泛型集合主要用于**读取/提供数据**（作为生产者），那么使用 `<? extends T>`。
- **Consumer Super (消费者使用 `super`)**: 如果你的泛型集合主要用于**写入/接收数据**（作为消费者），那么使用 `<? super T>`。

`<? extends T>` (上界通配符 - Upper Bounded Wildcard) 包括T在内的任何T的子类

`<? super T>` (下界通配符 - Lower Bounded Wildcard) 包括T在内的任何T的父类

### java中的String家族

`String`类具有不可变性，线程安全，对于字符串的拼接每次都需要新创对象，性能较差，有字符串常量池，帮助节省内存。java8之前是`char[]`，java9之后`byte[]+coder`。

`StringBuilder`类具有可变性，可以用 `append()`、`insert()`、`delete()` 等方法修改对象值而不新建对象，内部为一个可变的字符数组，线程不安全，适用于单线程场景。

`StringBuffer`类同样具有可变性，且线程安全，大多数方法都使用了`synchronized`关键字同步，由于同步操作的消耗，适用于多线程场景。

### java中的异常家族

```text
Throwable
├── Error（如 VirtualMachineError、OutOfMemoryError）
└── Exception
    ├── RuntimeException（如 NullPointerException、IllegalArgumentException）
    └── 检查异常（如 IOException、SQLException）
```

异常处理机制：

 try-catch-finally 块 与 方法后面的throws

异常主要分为两类：

- 未检查异常（unchecked exceptions）是继承自RuntimeException类或Error类的异常，编译器不强制要求进行异常处理。因此，对于这些异常，不需要在方法签名中使用throws来声明。
- 对于非检查异常，可以用try-catch包围且不需要方法后throws。

- 检查异常（checked exceptions） 除了未检查异常其他的类。java编译器会强制要求你必须处理这类异常。

- 对于检查异常，处理方法二选一：try-catch或方法后throws。

java中也可以通过继承 Exception 或 RuntimeException 创建自定义异常。

### java中的反射家族

Java 的反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。

反射具有以下特性：

1. 运行时类信息访问：反射机制允许程序在运行时**获取类的完整结构信息**，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。
2. 动态对象的创建：可以使用反射API动态地**创建对象实例**，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法（已废弃）或Constructor对象的newInstance()方法实现的。
3. 动态方法的调用：可以在运行时动态地**调用对象的方法**，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。
4. 访问和修改字段值：反射还允许程序在运行时**访问和修改对象的字段值**，即使是私有的。这是通过Field类的get()和set()方法完成的。

反射是作用在唯一的Class对象上。Class对象是类的元数据在JVM中的唯一表示，反射通过操作这个唯一的Class对象，得以动态地实例化出多个与该类类型相同的实例对象，这些实例对象是独立的，但都与同一个Class对象关联。

可以理解为：JVM在类加载拿到了蓝图之后，可以利用反射来源源不断地制造和蓝图相同的实例对象，且可以利用反射来调用方法、设置值、获取属性等。

java的反射机制主要应用场景：

- 开发框架：如Spring通过IoC控制反转利用反射创建Bean并DI注入依赖交由容器运行时使用。如碰到AOP相关注解时单独代理实例。
- 插件系统：根据配置加载未知的类。
- 序列化/反序列化：JSON的转换。
- 动态代理：实现AOP或拦截器。

### java中的注解家族

Java注解（Annotation）本质上是一种特殊的接口，它继承自 `java.lang.annotation.Annotation` 接口。注解本身并不直接影响代码的执行，而是作为一种元数据（metadata）嵌入到源代码、字节码或者在运行时被读取，为程序元素（如类、方法、字段等）提供额外的信息。这些信息可以被编译器、开发工具或运行时库所使用，以实现特定的功能。

当Java源代码被编译成字节码（`.class`文件）时，注解信息会根据其定义的保留策略被相应地处理。注解的生命周期由 `@Retention` 元注解指定：`RetentionPolicy.SOURCE` 表示注解仅保留在源代码中，编译时被丢弃；`RetentionPolicy.CLASS` 表示注解会被编译到字节码文件中，但在运行时对JVM不可见；而 `RetentionPolicy.RUNTIME` 则表示注解会被编译到字节码文件，并且在程序运行时可以被JVM加载和读取。在字节码文件中，这些运行时可见或不可见的注解信息会作为特定的属性（如 `RuntimeVisibleAnnotations` 或 `RuntimeInvisibleAnnotations`）存储起来。

在程序运行时，如果注解的保留策略是 `RUNTIME`，我们就可以通过Java的反射机制来获取这些注解信息。有趣的是，当我们通过反射API（例如 `Class.getAnnotation()` 或 `Method.getAnnotation()`）获取一个注解的实例时，Java虚拟机并不会直接创建一个实现了该注解接口的静态类实例。相反，JVM会动态地生成一个该注解接口的**代理类**实例。这个动态代理对象在被调用其定义的属性方法时，实际上会委托给一个名为 `AnnotationInvocationHandler` 的处理器。这个处理器会从一个内部的 `memberValues` 映射中查找并返回注解属性对应的值，而这些 `memberValues` 中的数据则来源于类加载时从字节码文件中解析出的注解属性数据，这些数据最初是在编译时从常量池和注解声明中固化的。

为了精确控制注解能够应用于哪些程序元素，Java提供了 `@Target` 元注解。通过 `@Target`，我们可以指定一个注解可以用于修饰类、接口、枚举、方法、字段、构造器、参数、局部变量等多种目标。因此，`@Retention` 决定了注解信息能保留到哪个阶段，而 `@Target` 则规定了注解可以“贴”在哪些地方，两者共同定义了注解的作用范围和实际应用场景。许多现代框架（如Spring）广泛利用运行时注解，通过反射读取这些元数据来驱动框架的自动化配置、依赖注入、行为拦截等动态功能。

### java的判断家族

java中存在三种方法来判断：

- `==` 对于基本数据类型，比较值是否相同；对于引用数据类型，比较两者引用是不是同一个地址值，即是否是同指向一个对象。 注意： `==`类型不兼容会报错，即 基本==基本或者引用==引用，特殊情况为 基本==包装类 会触发自动**拆箱**。
- `equals()`仅用于引用对象之间，比较两个对象的**内容**是否相等，当未被重写时行为与`==`相同。很多类重写了方法用于比较对象的内容。
- `hashCode()`返回对象的哈希码（一个整数），用于快速定位对象，默认基于内存地址，可被重写。

注意`equals()`与`hashCode()`必须同时重写，且要满足以下要求：

1. 一致性：如果 a.equals(b) 返回 true，则 a.hashCode() 必须等于 b.hashCode()。
2. 非对称性：如果 a.equals(b) 返回 false，a.hashCode() 和 b.hashCode() 可以相同（哈希冲突），但应尽量避免。
3. 稳定性：在一个对象的生命周期中，只要 equals 使用的属性未变，hashCode 必须始终返回相同值。

**相等的对象必须有相同的哈希码，但哈希码相同的对象不一定相等（equals）**。

对于哈希冲突可以应用

- 拉链法：将相同哈希码的对象放入同一个“桶”中，用链表（或类似结构）存储。如Java集合中的 HashMap 和 HashSet 。当相同哈希码数量过多时可以将链表转换为红黑树。
- 开放寻址法：在哈希表中找到另一个可用的位置来存储冲突的键值对，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列。
- 再哈希法（Rehashing）：当发生冲突时，使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对。
- 哈希桶扩容：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率。

### java的1.8版本

java的1.8版本引入很多有用工具：

- Lambda表达式：Lambda 表达式是一个**匿名函数**（没有名称的函数），可以将其理解为一段可以传递的代码块。**它通常用来实现函数式接口（只有一个抽象方法的接口）的行为。**Lambda 表达式通过简洁的语法替代了传统的匿名内部类，使代码更简洁、可读性更高。格式为：(参数) -> 主体 。
- 函数式接口：只有一个抽象方法的接口，可与 Lambda 配合使用，如`Predicate<Integer> isEven = n -> n % 2 == 0;`

- Stream API：对集合进行函数式操作，支持过滤、映射、归约等。
- 方法引用：用 `::` 简化 Lambda 表达式，引用已有方法，而不是提供一个Lambda表达式来调用它。 当你想要执行的Lambda表达式的主体恰好已经有一个现成的方法可以完成时，使用方法引用可以让代码更简洁、可读性更高。
- Base64编解码工具：如`Base64.getEncoder().encodeToString("text".getBytes());`

对于Lambda与函数式接口与方法引用：

```java
interface Dog {
    abstract void eat();
}

// 辅助类，包含一个静态方法
class DogActivities {
    public static void performStaticEat() {
        System.out.println("狗狗通过[静态方法引用]正在优雅地进食...");
    }
}

class Main {
    public static void main(String[] args) { 
        // 1. 匿名内部类实现
        Dog dogAnonymous = new Dog() {
            @Override
            public void eat() {
                System.out.println("我是通过匿名内部类实现的 eat 方法");
            }
        };
        dogAnonymous.eat();

        // 2. Lambda表达式实现
        Dog dogLambda = () -> {
            int b = 3; // Lambda可以有多行语句
            System.out.println("Lambda说：小狗吃了 " + b + " 块饼干");
        };
        dogLambda.eat();

        // 3. 方法引用 :: (引用静态方法)
        // DogActivities::performStaticEat 指向 DogActivities 类的静态方法 performStaticEat
        Dog dogStaticMethodRef = DogActivities::performStaticEat;
        dogStaticMethodRef.eat(); // 调用时会执行 DogActivities.performStaticEat()
    }
}
```

对于Stream API：它提供了一种声明式的方式来操作数据，支持过滤、映射、排序、归约等操作，并且可以轻松实现并行处理。

Stream的特点：

- 惰性求值，中间的操作不会立刻执行，只有遇到终端操作时才会触发计算。
- 一次性使用，Stream只能消费一次。
- 可以通过`parallelStream()` 或` parallel() `方法轻松实现并行处理。

Stream 的三个阶段：

- 创建：从数据源生成Stream。
- 中间操作：对数据进行操作返回新的Stream（包含了相关的操作逻辑）。
- 终端操作：触发执行并产生最终结果，关闭Stream。

如何创建Stream流：

1. 从集合创建

```java
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream = list.stream();         // 串行流
Stream<String> parallelStream = list.parallelStream(); // 并行流
```

2. 从数组创建

```java
String[] array = {"a", "b", "c"};
Stream<String> stream = Arrays.stream(array);
```

3. 直接创建

```java
Stream<Integer> stream = Stream.of(1, 2, 3, 4);从文件或I/O创建
```

4. 从文件或者I/O创建

```java
try (Stream<String> lines = Files.lines(Paths.get("file.txt"))) {
    lines.forEach(System.out::println);
} catch (IOException e) {
    e.printStackTrace();
}
```

5. 创建无限流

- `Stream.iterate()`：生成无限序列。
- `Stream.generate()`：通过 Supplier 生成。

```java
Stream<Integer> infinite = Stream.iterate(0, n -> n + 1); // 0, 1, 2, ...
Stream<Double> randoms = Stream.generate(Math::random);   // 随机数流
```

Stream API 的方法

中间操作：

| **方法**           | **描述**                       | **示例**                                 |
| ------------------ | ------------------------------ | ---------------------------------------- |
| filter(Predicate)  | 过滤符合条件的元素             | stream.filter(x -> x > 0)                |
| map(Function)      | 将元素映射为新值               | stream.map(String::toUpperCase)          |
| flatMap(Function)  | 将每个元素映射为一个流并扁平化 | stream.flatMap(x -> Stream.of(x, x+1))   |
| distinct()         | 去除重复元素                   | stream.distinct()                        |
| sorted()           | 按自然顺序排序                 | stream.sorted()                          |
| sorted(Comparator) | 按指定比较器排序               | stream.sorted(Comparator.reverseOrder()) |
| limit(long)        | 限制返回元素数量               | stream.limit(3)                          |
| skip(long)         | 跳过前 n 个元素                | stream.skip(2)                           |
| peek(Consumer)     | 查看元素（调试用），不改变流   | stream.peek(System.out::println)         |

终端操作

| **方法**                  | **描述**                                 | **示例**                            |
| ------------------------- | ---------------------------------------- | ----------------------------------- |
| forEach(Consumer)         | 对每个元素执行操作                       | stream.forEach(System.out::println) |
| collect(Collector)        | 将流收集为集合或其他结构                 | stream.collect(Collectors.toList()) |
| reduce(T, BinaryOperator) | 归约操作，合并元素为单一结果             | stream.reduce(0, Integer::sum)      |
| count()                   | 返回流中元素数量                         | stream.count()                      |
| anyMatch(Predicate)       | 检查是否至少有一个元素满足条件           | stream.anyMatch(x -> x > 0)         |
| allMatch(Predicate)       | 检查是否所有元素都满足条件               | stream.allMatch(x -> x > 0)         |
| noneMatch(Predicate)      | 检查是否没有元素满足条件                 | stream.noneMatch(x -> x < 0)        |
| findFirst()               | 返回第一个元素（Optional）               | stream.findFirst()                  |
| findAny()                 | 返回任意一个元素（Optional，适合并行流） | stream.findAny()                    |
| toArray()                 | 将流转换为数组                           | stream.toArray(String[]::new)       |

**并行流（Parallel Stream）** 是 Stream API 提供的一种功能，允许通过多线程并行处理数据，以充分利用多核处理器的计算能力，从而提高性能。可用 parallel() 方法将普通流转换为并行流。通过Fork/Join框架和线程池来确保运行。

### java的序列化与反序列化

要在不同的Java虚拟机（JVM）之间传递对象，我们不能直接共享内存中的对象，因为每个JVM都有其独立的内存空间。因此，核心方法是将对象的状态转换为一种可传输的数据格式，这个过程称为序列化；数据传输到目标JVM后，再从这种数据格式恢复成对象，即反序列化。这种机制使得对象的状态得以跨越JVM边界。

虽然Java本身提供了基于`java.io.Serializable`接口的内置序列化机制，它能将对象直接转换为字节流，但在许多现代应用中，开发者更倾向于使用更为通用和灵活的文本格式，特别是JSON。JSON格式因其轻量级和良好的可读性而广泛流行。主流的Java库如**Jackson**和**Fastjson**，它们能够非常方便地将Java对象序列化为JSON字符串，以及从JSON字符串反序列化回Java对象，这使得对象的数据表示不仅易于调试，也便于跨语言系统间的交互。

当一个对象被序列化成JSON字符串（或其他选定格式）后，这个字符串数据就可以通过网络从源JVM发送到目标JVM。常见的传输方式包括通过HTTP/HTTPS协议构建RESTful API接口，其中JSON作为请求体或响应体的内容；或者利用消息队列（如Kafka、RabbitMQ），将序列化后的对象数据作为消息进行异步传递。一旦目标JVM接收到这个JSON字符串，它会使用相应的库（如Jackson或Fastjson）进行反序列化，依据字符串内容在本地内存中重建Java对象。当然，为了成功反序列化，目标JVM的类路径下必须包含该对象的类定义，并且该类结构需要与JSON数据能够兼容。

### **java的I/O家族**

Java的I/O（输入/输出）机制是其核心功能之一，允许程序与外部世界（如文件系统、网络连接、其他程序等）进行数据交换。Java I/O体系结构设计得相当灵活，主要围绕“流”（Stream）的概念构建，使得开发者可以组合不同的流类来实现复杂的I/O操作。

早期的Java I/O（通常称为BIO，Blocking I/O）主要分为两大类：字节流和字符流。

- **字节流家族**以`InputStream`和`OutputStream`为基类，它们直接操作8位的字节数据，非常适合处理二进制文件（如图片、音频、视频）或任何原始字节序列。常用的实现类包括用于文件操作的`FileInputStream`和`FileOutputStream`，用于提升性能的缓冲流`BufferedInputStream`和`BufferedOutputStream`，以及能够读写Java基本数据类型和对象的`DataInputStream`/`DataOutputStream`与`ObjectInputStream`/`ObjectOutputStream`（这与你之前总结的序列化紧密相关）。

- **字符流家族**，其基类为`Reader`和`Writer`。字符流操作16位的Unicode字符数据，并且能够自动处理字符集编码和解码，因此更适合处理文本文件。常见的字符流包括直接操作文件的`FileReader`和`FileWriter`（它们使用平台默认字符集），以及非常重要的桥接流`InputStreamReader`（将字节输入流转换为字符输入流）和`OutputStreamWriter`（将字符输出流转换为字节输出流），这两者允许在转换时显式指定字符编码。为了提高读写效率和提供更便捷的文本行操作，`BufferedReader`（提供了`readLine()`方法）和`BufferedWriter`，以及格式化输出的`PrintWriter`也经常被使用。

从Java 1.4开始，引入了

- NIO（New I/O，或Non-blocking I/O），位于`java.nio`包下。通常被描述为一种同步非阻塞的I/O模型。NIO的核心在于其三大组件：**通道（Channels）**、**缓冲区（Buffers）和选择器（Selectors）**。NIO的**通道**代表了与I/O设备（如文件、套接字）的连接，数据通过通道传输，并且通道可以被设置为非阻塞模式。这意味着当执行读写操作时，如果数据没有准备好或无法立即写入，操作会马上返回，而不是让线程阻塞。数据传输则依赖**缓冲区**，这是一块内存区域，数据从通道读入缓冲区或从缓冲区写入通道。实现高效I/O多路复用的关键是**选择器**。它允许单个线程监控多个通道的I/O事件（如连接、读就绪、写就绪）。应用程序将通道注册到选择器上，并指定感兴趣的事件。然后，线程调用选择器的`select()`方法，该方法会阻塞直到至少一个注册的通道上发生了感兴趣的事件（或超时）。此时，`select()`方法返回，线程可以获取就绪通道的集合，并对这些通道进行相应的（通常是非阻塞的）I/O操作。这种机制的底层依赖于操作系统提供的I/O多路复用功能（如`epoll`、`kqueue`），使得一个线程能有效地管理大量并发连接，大大减少了线程数量和上下文切换的开销，提高了系统的伸缩性。

随后，Java 7进一步增强了I/O能力，引入了

- NIO.2，其核心改进主要体现在`java.nio.file`包中。NIO.2提供了一套更为现代化和强大的文件系统API，其核心类包括`Path`（用于表示文件或目录的路径）、`Paths`（创建`Path`实例的工厂类）和`Files`（包含大量用于操作文件和目录的静态实用方法）。NIO.2支持更细致的文件属性访问、符号链接操作、文件树遍历以及通过`WatchService`监视目录变化等高级功能，从而在很大程度上取代了老旧且功能相对局限的`java.io.File`类。

关于不同I/O模型的区别，可以这样理解：

**BIO（Blocking I/O）**，即传统的`java.io`包，它基于流模型实现，交互方式是同步阻塞的。这意味着在读写操作完成前，执行线程会一直阻塞，调用顺序是可靠的线性序列。其优点是代码简单直观，缺点则是I/O效率和扩展性较低，容易成为应用性能的瓶颈。

**NIO（Non-blocking I/O）**，由Java 1.4引入的`java.nio`包，提供了通道、选择器、缓冲区等新抽象，用以构建多路复用的、同步非阻塞的I/O程序。NIO提供了更接近操作系统底层的高性能数据操作方式，允许单线程管理多个连接。

而**AIO（Asynchronous I/O）**，自Java 1.7（作为NIO.2的一部分）引入，通常被认为是NIO的进一步升级。它提供了异步非阻塞的I/O操作方式。异步I/O基于事件和回调机制实现：应用程序发起I/O操作后会立即返回而不会阻塞，当后台I/O处理完成后，操作系统会通知相应的线程（例如通过回调函数）进行后续操作。

## java的集合框架

集合与数组的区别：

数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素。

数组可以包含基本数据类型和对象，而集合只能包含对象。数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。

集合中的顶级接口是Collection，和Collections类的区别：

Collection是Java集合框架中的一个接口，它是所有集合类的基础接口。它定义了一组通用的操作和方法，如添加、删除、遍历等，用于操作和管理一组对象。

Collections（注意有一个s）是Java提供的一个工具类，位于java.util包中。它提供了一系列静态方法，用于对集合进行操作和算法。Collections类中的方法包括排序、查找、替换、反转、随机化等等。这些方法可以对实现了Collection接口的集合进行操作，如List和Set。

对于集合中的元素的遍历可以有以下几种方法：

for循环、增强for、for-each、Iterator迭代器 、Stream API

### java的集合家族

![img](https://cdn.nlark.com/yuque/0/2025/png/50462032/1747393405064-997cd12b-7241-489b-b068-5e95f0217f59.png)

#### List

##### Vector

- 线程安全（方法几乎全用 `synchronized`关键字修饰） 。
- 底层结构 动态数组（`Object[]`），可以根据需要自动的增加容量，当数组已满时，会创建新的数组（增加一倍），并拷贝原有数组数据。
- FILO队列。可以模拟栈队列。

##### Stack extends Vector

- 线程安全。
- 底层结构 动态数组（`Object[]`）扩容增加一倍。
- FILO。
- 专门提供了更清晰的 LIFO 语义。（`push()`、`pop()`、`peek()`、`empty()`等）。

##### ArrayList

- 线程不安全。
- 底层结构 动态数组（`Object[]`）。
- 数组实现 一般扩容1.5倍。先计算容量，创建一个新数组，将内容复制后更改引用。
- 基于索引的访问效率高。在列表末尾添加删除元素很快。中间操作会导致后续元素移动时间复杂度O(n)。随机删除很快。
- 经常会出null问题索引越界问题。

##### CopyOnWriteArrayList

- 线程安全
- 底层结构 动态数组（`Object[]`）
- 工作原理：读取操作时，直接访问。写操作时，先获取内部锁（`ReentrantLock`），复制当前数组，创建一个新数组（长度加1），在新数组上操作，将内部数组引用指向这个新数组，最后释放锁。

##### LinkedList

- 线程不安全。
- 双向链表结构 不需要扩容。
- 头尾增删改效率高，随机查询效率低。随机删除要先遍历。
- 可以用作队列或者栈使用。

#### Set

##### HashSet

- 特点：元素唯一，**无序**。

- 实现：基于哈希表。

- 适用场景：当你只需要保证元素唯一，而不关心元素的排列顺序，并且追求高效率时。

##### LinkedHashSet

- 特点：元素唯一，**保持插入顺序**。
- 实现：基于哈希表和双向链表。
- 适用场景：当你既需要保证元素唯一，又需要记录元素被添加进集合的先后顺序时。

##### TreeSet

- 特点：元素唯一，**按元素的自然顺序或自定义比较器顺序排序**。
- 实现：基于红黑树。
- 适用场景：当你需要一个自动排序的、元素唯一的集合时。

##### Set集合有什么特点？如何实现key无重复的？

- **set集合特点**：Set集合中的元素是唯一的，不会出现重复的元素。
- **set实现原理**：Set集合通过内部的数据结构（如哈希表、红黑树等）来实现key的无重复。当向Set集合中插入元素时，会先根据元素的hashCode值来确定元素的存储位置，然后再通过equals方法来判断是否已经存在相同的元素，如果存在则不会再次插入，保证了元素的唯一性。

##### 有序的Set是什么？记录插入顺序的集合是什么？

- **有序的 Set 是TreeSet和LinkedHashSet**。TreeSet是基于红黑树实现，保证元素的自然顺序。LinkedHashSet是基于双重链表和哈希表的结合来实现元素的有序存储，保证元素添加的自然顺序
- **记录插入顺序的集合通常指的是LinkedHashSet**，它不仅保证元素的唯一性，还可以保持元素的插入顺序。当需要在Set集合中记录元素的插入顺序时，可以选择使用LinkedHashSet来实现。

#### Queue

`Queue`（队列）接口是 Java 集合框架的一部分，它继承自 `Collection` 接口，主要用于实现在处理元素前保存元素的集合，通常（但不一定）以 **FIFO（First-In, First-Out，先进先出）** 的方式对元素进行排序。这意味着元素通常从队列的一端（尾部）插入，从另一端（头部）移除。

##### Deque

- `Deque`（Double Ended Queue，双端队列）接口继承自 `Queue` 接口，它支持在队列的两端进行元素的插入和移除操作。因此，`Deque` 既可以作为标准的 FIFO 队列使用，也可以作为 **LIFO（Last-In, First-Out，后进先出）的栈**使用。
- 可头插 `offerFirst() / addFirst()` 移除`removeFirst() / pollFirst()`检查`getFirst() / peekFirst()`
- 尾部插 `offerLast() / addLast()` 移除`removeLast() / pollLast()`检查`getLast() / peekLast()`

##### PriorityQueue

- `PriorityQueue` 是一种特殊的队列，它不遵循严格的 FIFO 原则，而是根据元素的**优先级**进行出队操作。每次调用 `poll()` 或 `remove()` 方法时，都会移除并返回优先级最高的元素。

- 底层通常基于**二叉堆（binary heap）实现。默认情况下，它是一个最小堆 (min-heap)**，即优先级最高的元素是值最小的元素。可以通过在构造时传入自定义的 `Comparator` 来实现最大堆 (max-heap) 或其他自定义优先级规则。

- `add()` 或 `offer()` 方法用于添加元素，时间复杂度为 O(log n)。

  `poll()` 或 `remove()` 方法用于移除并返回优先级最高的元素，时间复杂度为 O(log n)。

  `peek()` 方法用于查看优先级最高的元素但不移除，时间复杂度为 O(1)。

  线程不安全。

  不允许存储 `null` 元素。

  允许存储重复元素，但它们的相对顺序（如果优先级相同）未定义。

### java的Map家族

![img](https://cdn.nlark.com/yuque/0/2025/png/50462032/1747393472616-508d40d8-f84c-48e0-b616-3d406b7b5cf1.png)

#### Map

##### HashMap

`HashMap` 内部使用一个数组（通常称为“桶数组”或 "hash table"）来存储键值对（Entry）。

- 线程不安全 多线程可能发生的问题：如果多线程计算出元素索引位置相同会出现覆盖导致丢失。以及JDK1.8之前通过头插法会造成死循环。
- 底层：JDK1.8之前是：数组+链表 更新后：数组+链表，当链表过长（8个）时转为红黑树。
- 初始容量16 为什么是2的n次方：扩容时，新数组的容量依然是旧数组的两倍，但元素在新数组中的位置判断更为巧妙，系统不再为每个元素重新计算完整的哈希索引，而是通过检查元素哈希值的某一个特定二进制位（具体是 `hash & 旧容量` 的结果）。若该特定位为0，则元素在新数组中的索引与旧索引保持一致；若为1，则新索引为“原索引 + 旧数组容量”。这样，原先一个桶中的元素会被高效地、且保持相对顺序地分配到新数组的两个确定位置中，减少了计算开销并改善了哈希冲突的分布。
- 一般用String做Key，不能被修改保证Key的稳定性，可变的Key可能会导致hashCode和equals方法不一致。Key可以为Null 直接会令哈希为0，且只能有一个，Value可以有多个Null。
- HashMap会使用Key对象的hashCode()和equals方法去决定key-value对的索引以及取Value，要注意重写equals和hashCode方法：
  - 如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。
  - 如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。
- 存入元素：HashMap通过哈希算法将元素的键（Key）映射到数组中的槽位（Bucket）。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上。当同一个槽位的元素过多时，转为红黑树。小于6时转回链表。具体过程：
  - `HashMap` 首先调用 **`key` 对象**的 `hashCode()` 方法，得到一个整数哈希码。再计算这个哈希码所映射到数组的索引位置（桶的索引值）。
  - 如果没元素，则直接在该位置创建一个新的Entry对象来存储键值对。将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置。将HashMap的修改次数（modCount）加1，以便在进行迭代时发现并发修改。
  - 如果该位置有元素 调用**`key` 对象**的 `equals()` 方法，如果找到一个 `equals()` 返回 `true` 的 `key`，那么就认为这个 `key` 已经存在，新的 `value` 会覆盖旧的 `value`。
  - 如果第一个键值对的哈希码和键不相同，则需要遍历链表或红黑树来查找是否有相同的键。**如果是链表**：从链表的头部开始逐个比较键的哈希码和equals()方法，直到找到相同的键或达到链表末尾。找到就替换，没找到，则将新的键值对添加到链表的**头部**。**如果是红黑树**：在红黑树中使用哈希码和equals()方法进行查找。根据键的哈希码，定位到红黑树中的某个节点，然后逐个比较键，直到找到相同的键或达到红黑树末尾。找到就替换，找不到就添加到红黑树中。
  - 检查长度阈值：链表与红黑树转换
  - 检查负载因子是否超过阈值（0.75）：如果键值对的数量（size）与数组的长度的比值大于阈值，则需要进行扩容操作。扩容：
    - 第一步将哈希表扩容，成原来的2倍。
    - 第二步将旧哈希表中的数据放到新的哈希表中。（原位置或者移动2次幂的位置）
    - 为什么选0.75？经验值与统计学，在理想情况下（哈希函数能将元素均匀分布），当加载因子为 `α`时，一个桶中元素的数量可以近似看作服从参数为 `α`的泊松分布。
    - 例子：

“苹果的哈希码是5”，“香蕉的哈希码是21”时，指的是它们的**原始哈希码**。

- **苹果：** 原始哈希码是5。在16个桶的系统里，它的桶编号是 `5 & 15 = 5`。(这里的15就是 n-1)
- **香蕉：** 原始哈希码是21。在16个桶的系统里，它的桶编号是 `21 & 15 = 5`。

所以，它们俩因为各自不同的原始哈希码（5 和 21），恰好都进入了编号为5的桶，并在这个桶里形成了链表。

在达到0.75因子之后扩容 原本16个桶位变成了32个桶 怎么把他们分过去呢？利用新加一位的按位与

苹果 0000 0101 (hash)

香蕉 0001 0101 (hash)

他们在扩容之前在哪个桶？

n-1        0000  1111& =>0000 0101 (第5号桶)

苹果       0000 0101

n-1        0000  1111& =>0000 0101 (第5号桶)

香蕉       0001 0101

他们扩容之后呢

n-1        0001  1111& =>0000 0101 (第5号桶)

苹果      0000 0101

n-1        0001  1111& =>0001 0101 (第21号桶)

香蕉      0001 0101

##### LinkedHashMap

- 线程不安全
- 底层：双向链表

##### TreeMap

- 线程不安全
- 底层：红黑树，可以对键进行排序默认按照自然顺序排序。

##### HashTable

- HashTable是线程安全的，实现方式是所有公共方法均采用synchronized关键字。
- 默认容量11 每次扩容到之前的`2n+1`。
- Hashtable的底层数据结构主要是**数组加上链表**，数组是主体，链表是解决hash冲突存在的。

##### ConcurrentHashMap

- 线程安全 JDK1.8以前：分段锁：数据被分为多个`Segment`每个段都有自己的锁，可允许多个线程操作不同的段，提高并发效率。 JDK1.8：volatile + CAS 或者 synchronized。
- 在 JDK 1.7 中它使用的是数组加链表的形式，而数组又分为：大数组 Segment 和小数组 HashEntry。 Segment是一种可重入锁（ReentrantLock），在 ConcurrentHashMap 里扮演锁的角色；HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。
-  JDK 1.8 则使用了数组 + 链表/红黑树的方式优化了 ConcurrentHashMap 的实现
- JDK1.8时添加数据：首先会判断容器是否为空，如果为空则使用 volatile 加 CAS 来初始化，如果容器不为空，则根据存储的元素计算该位置是否为空。如果根据存储的元素计算结果为空，则利用 CAS 设置该节点；如果根据存储的元素计算结果不为空，则使用 synchronized ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。

#### Map的遍历方法

- for-each + entrySet() 方法 同时获取Map中的键和值。

```java
// 使用for-each循环和entrySet()遍历Map
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
        }
```

- 使用for-each循环和keySet()方法 

```java
// 使用for-each循环和keySet()遍历Map的键
        for (String key : map.keySet()) {
            System.out.println("Key: " + key + ", Value: " + map.get(key));
        }
```

- 使用迭代器

```java
 // 使用迭代器遍历Map
        Iterator<Entry<String, Integer>> iterator = map.entrySet().iterator();
        while (iterator.hasNext()) {
            Entry<String, Integer> entry = iterator.next();
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
        }
```

- 使用 Lambda 表达式和forEach()方法

```java
// 使用Lambda表达式和forEach()方法遍历Map
        map.forEach((key, value) -> System.out.println("Key: " + key + ", Value: " + value));
```

#### HashMap和Hashtable、ConcurrentMap的区别

- HashMap线程不安全，效率高一点，可以存储null的key和value，null的key只能有一个，null的value可以有多个。默认初始容量为16，每次扩充变为原来2倍。创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。
- HashTable线程安全，效率低一点，其内部方法基本都经过synchronized修饰，不可以有null的key和value。默认初始容量为11，每次扩容变为原来的2n+1。创建时给定了初始容量，会直接用给定的大小。底层数据结构为数组+链表。它基本被淘汰了，要保证线程安全可以用ConcurrentHashMap。
- ConcurrentHashMap是Java中的一个线程安全的哈希表实现，它可以在多线程环境下并发地进行读写操作，而不需要像传统的HashTable那样在读写时加锁。ConcurrentHashMap的实现原理主要基于分段锁和CAS操作。它将整个哈希表分成了多Segment（段），每个Segment都类似于一个小的HashMap，它拥有自己的数组和一个独立的锁。在ConcurrentHashMap中，读操作不需要锁，可以直接对Segment进行读取，而写操作则只需要锁定对应的Segment，而不是整个哈希表，这样可以大大提高并发性能。

### java常用集合代码段

| 数据结构      | 底层实现 | 顺序性 | 重复性 | 线程安全 | 主要操作复杂度       | 典型用途       |
| ------------- | -------- | ------ | ------ | -------- | -------------------- | -------------- |
| ArrayList     | 动态数组 | 有序   | 可重复 | 否       | 访问 O(1), 增删 O(n) | 动态列表       |
| LinkedList    | 双向链表 | 有序   | 可重复 | 否       | 头尾 O(1), 访问 O(n) | 队列、双端操作 |
| Stack         | 动态数组 | LIFO   | 可重复 | 是       | 顶部 O(1)            | 栈操作         |
| ArrayDeque    | 循环数组 | 双端   | 可重复 | 否       | 头尾 O(1)            | 栈/队列替代    |
| HashSet       | 哈希表   | 无序   | 无重复 | 否       | 平均 O(1)            | 去重           |
| TreeSet       | 红黑树   | 有序   | 无重复 | 否       | O(log n)             | 排序集合       |
| HashMap       | 哈希表   | 无序   | 键唯一 | 否       | 平均 O(1)            | 键值映射       |
| TreeMap       | 红黑树   | 有序   | 键唯一 | 否       | O(log n)             | 排序映射       |
| PriorityQueue | 二叉堆   | 优先级 | 可重复 | 否       | 增删 O(log n)        | 优先级任务     |

````java
List<Integer> list = new ArrayList<>(); //动态数组
add() remove() indexOf() contains() size()

Queue<Integer> queue = new LinkedList<>();//双向链表 先进先出
offer() poll() peek() contains() size()

Stack<Integer> stack = new Stack<>();//动态数组 先进后出
push() pop() peek() size()

Deque<Integer> deque = new ArrayDeque<>();//循环数组 可选两头出入
offer() offerFirst/Last() pool() pollFirst/Last() peek() peekFirst/Last()  size()

Set<Integer> hashSet = new HashSet<>();//哈希表
add() remove() contains() size()

Set<Integer> treeSet = new TreeSet<>(); //红黑树 TreeSet 默认按自然顺序（升序）排序
add() remove() contains() size() first() last()

Map<Integer,Integer> hashMap = new HashMap<>();//哈希表
put() remove() get() containsKey() containsValue() size()

Map<Integer,Integer> treeMap = new TreeMap<>();//红黑树 TreeMap 默认按自然顺序（升序）排序
put() remove() get() containsKey() containsValue() size() firstKey() lastKey()

PriorityQueue<Integer> pq = new PriorityQueue<>();
//二叉堆(默认最小堆，可自定义 Comparator 实现最大堆）
//进出顺序：按优先级出队（默认升序，最小元素先出）
offer() add() poll() remove() peek() contains() size()
````

## java的高效家族：JUC

JUC通常指`java.util.concurrent`包。

注：Java 底层会调用 pthread_create 来创建线程，所以本质上 java 程序创建的线程，就是和操作系统线程是一样的，是 1 对 1 的线程模型。

使用多线程就要注意线程安全问题，Java的线程安全在三个方面体现：

- **原子性**：提供互斥访问，**同一时刻只能有一个线程对数据进行操作**，在Java中使用了atomic包（这个包提供了一些支持原子操作的类，这些类可以在多线程环境下保证操作的原子性）和synchronized关键字来确保原子性；
- **可见性**：一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了synchronized和volatile这两个关键字确保可见性；
- **有序性**：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。
