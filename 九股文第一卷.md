# Java

## java语言的特点

1. “一次编写，到处运行”。Java编译器将源代码编译成字节码（bytecode），该字节码可以在任何安装了Java虚拟机（JVM）的系统上运行。
2. 面向对象。Java是一门严格的面向对象编程语言，几乎一切都是对象。面向对象编程（OOP）（Object Oriented Program）代码更易于维护和复用，OOP的三大特性：继承、封装、多态。
3. 内存管理。Java拥有自己的GC（Garbage Collection）机制，自动管理内存和回收不再使用的对象。开发者不再需要手动管理内存，从而减少内存泄露等问题。

java最突出的特点：面向对象

面向对象（Object-Oriented Programming, OOP）是一种编程思想，它通过**模拟现实世界中的对象**来组织和管理代码。核心是将**数据和**操作数据的**方法绑定在一起**，形成“对象”，然后通过对象之间的交互来完成程序功能。以下是简单理解面向对象的三个基本特性：封装、继承和多态。

 **封装 (Encapsulation)：**

封装就是把对象的属性（数据）和行为（方法）打包在一起，对外隐藏细节，只暴露必要的接口。

 **继承 (Inheritance)**

继承允许一个类（子类）继承另一个类（父类）的属性和方法，复用代码并扩展功能。

 **多态 (Polymorphism)**

多态是指同一个接口或方法，在不同对象上有不同的实现方式。多态可以提高代码的扩展性和复用性，分为编译时多态（重载）和运行时多态（重写）。

**编译时多态（重载）**：方法重载是指**同一类中**可以有多个同名方它们具有不同的参数列表（参数类型、数量或顺序不同）。虽然方法名相同，但根据传入的参数不同，编译器会在编译时确定调用哪个方法。

**运行时多态（重写）**：方法重写（Method Overriding）**子类重写父类**的方法，父类引用指向子类对象时，运行时根据实际对象类型决定调用哪个方法。如 父类 Animal 定义了 sound() 方法，子类 Dog 和 Cat 重写它。

**接口多态（Interface Polymorphism）：**多个类实现同一个接口，接口类型的引用可以指向任意实现类的对象，调用时执行具体实现。

## java程序的开始：JVM

java文件的运行：在编写完java代码后将其保存到后缀名为`.java`的文件中，再由`JDK`中的`javac`编译器编译成字节码，保存在`.class`后缀名的文件中，字节码会运行在`JDK`中的`JVM`上，`JVM`是Java运行的核心，会将字节码成本地机器码来执行。

java的JDK：一个JDK 包含了 编译器（`javac`）、调试器、开发工具、JRE（java runtime environment）。

JDK中的JRE：包含了类加载器、java类库以及`JVM` 。

java的解释性和编译性：不同于编译性语言c/cpp一次性全部编译成机器码，java首先利用编译器`javac`将其编译成字节码，这体现了java语言的编译性。而编译后的字节码是不能直接在操作系统上运行的，需要由JVM来执行。JVM 最初可以逐条解释执行字节码指令，将其翻译成对应操作系统的机器码，这体现了 Java 语言的解释性。为了提升性能，JVM 还会使用 `JIT (Just-In-Time Compilation)` 即时编译技术，在程序运行时将频繁执行的“热点代码直接编译成本地机器码。这些被 JIT 编译后的代码后续会直接以本地机器码的形式执行，从而大大提高了运行效率。因此，Java 是一种结合了编译特性和解释特性的语言。

当写完整个java代码后，发生的事情：

......进入JVM后：JVM管理的内存空间可以分为两类

第一类是线程共享区域：

- 堆（heap）是内存中最大的一块也是GC的主要区域，主要存放对象实例和数组。所有线程都可访问堆中的实例。堆主要分为 新生代（Eden区(占大部分默认8/10) -> Survivor0区 -> Survivor1区）（默认1/3区域） 老年代 （默认2/3区域）
- 方法区主要存被JVM所加载的类信息、常量、静态变量、JIT编译后的代码缓存等。注意：永久代(JDK8移除)/元空间（使用的是本地内存）是方法区的实现。

第二类是线程私有区域：

- 栈（stack）每个方法在执行的时候都会创建一个栈帧的结构，记录局部变量表、操作数栈、动态链接、方法出口等信息。
- 本地方法栈 为虚拟机用到的本地方法服务。
- 程序计数器 字节码行号指示器。

```java
public class Dog{
    private int age;
    private String name;
    
    public Dog(int age ,String name){
        //this指的是调用此方法的实例 也就是dog1 把4赋值给dog1的age
        this.age = age;
        this.name = name;
    }
    public void eat(){
        System.out.println("eat");
    }
}

public class Main{
    public static void main(String[] args){
        Dog dog1 = new Dog(4,"doo");
        String a = "dog1";
        int b = 3;
        //发生了自动装箱
        //Double c = Double.valueOf(3.0);
        Double c = 3.0;
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
    }
}
```

堆：

- `Dog` 对象实例 (包含原始类型 `age` 的值 `4`，和指向 `"doo"` String 对象的引用 `name`)。

- String 对象 `"doo"` (通常在字符串常量池)。

- String 对象 `"dog1"` (通常在字符串常量池)。

- `Double` 对象实例 (包装了 `double` 值 `3.0`，由自动装箱产生)。

栈：

- 局部变量 `dog1`: 存储 `Dog` 对象在堆上的内存地址。
- 局部变量 `a`: 存储 `"dog1"` String 对象在堆上的内存地址。
- 局部变量 `b`: 直接存储原始类型 `int` 的值 `3`。
- 局部变量 `c`: 存储 `Double` 对象在堆上的内存地址。

从中可以看到Java堆是JVM中内存占比最大的区域，用于存放所有对象实例和数组，因此是垃圾收集器（GC）的主要工作区域。GC的核心策略是基于可达性分析：从GC Roots（一组必须存活的引用）出发，遍历并标记所有可达的对象。对于那些在分析后被确定为不可达的对象，如果它们覆盖了`finalize()`方法且该方法尚未被执行，这些对象会被放入一个特定的队列，由一个低优先级的Finalizer线程去调用它们的`finalize()`方法（这给了对象一次“复活”的机会，但不推荐依赖此机制）；如果对象没有覆盖`finalize()`方法，或者其`finalize()`方法已经被调用过，并且在`finalize()`执行后仍然不可达，那么这些对象就会在后续的清理阶段被GC回收内存。

相对地，在GC中存活下来的对象则会经历一个“晋升”的过程：新创建的对象通常首先被分配在新生代的Eden区。当Eden区满触发Minor GC后，存活的对象会被复制到Survivor区（S0或S1中的一个），并且对象的年龄会增加。对象在Survivor区之间经历多次Minor GC（通常是15次，可配置）后仍然存活，就会被晋升到老年代。需要特别明确的是，**Java对象实例并不会被转移到永久代（PermGen，存在于JDK 7及之前版本）或元空间（Metaspace，从JDK 8开始使用）中**；这些区域主要负责存储类的元数据信息（如类结构、方法、字段）、常量池、静态变量以及即时编译器编译后的代码等，而非程序运行时动态创建的对象实例本身。

而JVM的GC分类可以分为以下三种：

- Minor GC 新生代回收 指发生在新生代（Young Generation）的垃圾收集动作。新生代通常包括Eden区和两个Survivor区（S0和S1）。通常是当Eden区满时触发。 Minor GC 非常频繁，回收速度相对较快，因为新生代中的对象大多是“朝生夕死”的。它通常会引发较短的“Stop-the-World”（STW，应用线程暂停）。新生代主要使用“复制”（Copying）算法。
- Major GC 老年代回收 指发生在老年代（Old Generation/Tenured Generation）的垃圾收集动作。通常是老年代空间不足时，或者由一些策略（如空间分配担保失败）触发。Major GC 的频率通常比 Minor GC 低，但执行时间通常会更长，STW时间也可能更长。
- Full GC 整堆回收 当老年代空间不足或者元空间等不足的时候。 Full GC 是所有GC类型中速度最慢的，STW时间最长，对应用程序的性能影响最大。应尽量避免或减少Full GC的发生。

当前java版本默认使用的垃圾收集器为G1 (Garbage-First) Collector 一种服务器端的垃圾收集器，面向大内存（通常4GB以上）应用，目标是在可控的停顿时间内实现高吞吐量。基于“**标记-整理**”（Region内部）和整体上的“复制”（Region之间）。采用分代和Region化（将堆划分为多个大小相等的独立区域）的思路。大部分工作可以并发执行，STW时间相对可预测。

除了G1垃圾收集器还有

Serial GC (串行收集器)：对新生代采用复制算法，在进行垃圾收集时必须STW并由单个GC线程完成收集工作。对老年代采用标记-整理算法，同样STW以及单个线程工作。单核情况下简单高效但是STW时间较长。

以及Parallel GC / Parallel Scavenge (并行收集器 / 吞吐量优先收集器)：新生代采取复制算法，与串行收集器不同，它会调用多个GC线程，缩短STW时间。老年代采取标记-整理算法，同样多个GC线程并行。多核CPU吞吐量高。

至于GC的算法的进化主要分成了以下三类：

1. 复制算法：将内存分为两块，一块快要满了后将内存复制到另外一块上并把原来的内存块清除，很明显空间利用不足。注意优点有不会产生内存碎片化。
2. 标记-清除算法：分为标记和清除两个阶段，可达性分析标记要被回收的部分再清除，很明显内存碎片化和效率低。
3. 标记-整理算法：标记后不先清理，会将存活对象移到内存另一端再清理掉剩余部分，很明显解决了内存碎片化但是效率低。

接下来就是JVM中的类加载机制：

类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括以下 7 个阶段：

加载 -》 验证 -》 准备 -》 解析 -》 初始化 -》 使用 -》 卸载 or

加载 -》 链接 -》 初始化 -》 使用 -》 卸载

- 加载：java将字节码读入JVM中。
- 链接：
  - 验证：JVM检查字节码合规性。
  - 准备：创建并对类变量（static修饰）赋默认初始值，分配内存空间。
  - 解析：将常量池中的符号引用，替换为直接引用。
- 初始化：实现类初始化的代码逻辑如静态字段赋值或者执行静态初始化块内的逻辑。

当一个类加载请求发出后，会由类加载器来加载，类加载器主要分为：

启动类加载器（java核心库） 《- 扩展类加载器（java扩展jar包类库） 《- 应用程序加载器（用户类路径类库） 《- 用户自定义类加载器（自定义类加载）

JVM的类加载器有一个特殊机制：双亲委派机制：其核心机制是：当一个类加载器收到类加载请求时，他不会首先自己去加载这个类，而是委派父加载器去完成，因此最终会被传达到顶层的启动类加载器，只有父加载器无法负担时才会由子加载器加载。

而这个双亲委派机制可以有效地达到以下几个作用：

1. 保证类的唯一性，避免了不同加载器加载重复类的情况，保证类库统一性。
2. 保证安全性，启动类加载器只加载信任类路径的类，java核心类不会有安全风险。
3. 隔离性，各个加载器加载自身的类加载请求，保证职责清晰。

## java的基本语法

### java中的数据类型家族

主要分为两类：

- 基本数据类型：byte(8位) char(16位) boolean short(16位) int(32位) long(64位) float(32位) double(64位)  （注意：取值范围-2^(n-1)~2^(n-1)-1）
- 引用数据类型：类 接口 数组

java中的数据类型之间也存在转换关系：

- 自动类型转换：目标范围大时，自动转换 。
- 强制类型转换：目标范围小时，强制转换可能出现数据丢失溢出问题。
- 字符串转换：Java提供了将字符串String类型转换为其他数据类型的方法，比如`Integer.parseInt()`
- 数值之间的转换：可以将整形转换为字符型等通过包装类实现。

java除了提供数据类型之间的转换，也提供了对象之间的转换。

- 向上转换：子类转为父类，会进行自动转换。向下转换：需要强制转换。注意需要确保对象实际类型匹配。

以及包装类与基本类型的转换：

- 装箱：基本类型转为包装类。
- 拆箱：包装类转为基本类型。

为什么会有包装类呢？

比如Integer对应是int类型的包装类，就是把int类型包装成**Object**对象，对象封装有很多好处，**可以把属性也就是数据跟处理这些数据的方法结合在一起**，比如Integer就有parseInt()等方法来专门处理int型相关的数据。

另一个非常重要的原因就是**在Java中绝大部分方法或类都是用来处理类类型对象的**，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。以及在Java中，泛型只能使用引用类型，而不能使用基本类型。

对于java中的BigDecimal类和Double类：

Double 在处理浮点数时存在精度丢失的问题，而 BigDecimal 可以提供任意精度的精确计算。Double 是浮点数，而BigDecimal 直接以十进制运算，结果精确无误差。

java中为了提升效率性能有缓存池的存在：

- String 字符串常量池 如果后续有相同字面量的String会直接引用池中已有对象。
- Integer等 包装类常量池 为减少自动装箱拆箱中创建对象的开销 其中如Integer池：默认缓存 -127~128之间的Integer对象。
- BigDecimal常量池
- 枚举类常量池

### java中的高频关键字家族

- abstract：
  - 修饰类时，即为抽象类，特点是可以包含抽象方法也可以包含具体方法。
  - 修饰方法时，此方法为抽象方法，只有方法声明没有方法体，必须在非抽象子类中被重写实现。
- final：
  - 修饰类时表示这个类不能被继承，是最终的实现。
  - 修饰基本数据类型变量时表示变为常量，一旦赋值不可改变。修饰引用类型变量时其引用一旦指向一个对象后就不能再指向其他对象，但该引用所指向的对象内容是可以修改的（除非对象本身也是不可变的，如`String`）。
  - 修饰方法禁止子类重写方法，不能更改其逻辑。
- static：可以修饰方法和变量。
  - 修饰变量时可以看作为全局的共享变量，可以直接通过类名访问，且随着类的生命周期存在。
  - 修饰方法时，可以直接类名调用，不用创建对象，且只能访问静态成员（包括静态字段和静态方法）。
- this：`this` 关键字是对**当前对象实例**的引用。也就是说，`this` 指向调用该方法或构造器的那个对象。
  - 在类的构造时使用`this`即区分成员变量和局部变量。
  - 在类的方法中使用`this`即调用当前类中的其他方法。
- super：是在子类中用于访问父类成员的关键字。可以调用父类的构造器以及访问父类成员。
- synchronized：
  - 在代码块中表示上可重入锁，线程安全。
  - 在方法上表示同步方法，线程安全。

### java中的泛型家族

泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。

泛型的主要目的是在编译时提供更强的类型检查，**从而**避免了在运行时因类型不匹配而导致类型转换异常（`ClassCastException`）。虽然大部分类型信息被擦除，但编译器会插入必要的类型转换并利用桥接方法等技术来保证类型安全。

泛型中的extends与super：

- **Producer Extends (生产者使用 `extends`)**: 如果你的泛型集合主要用于**读取/提供数据**（作为生产者），那么使用 `<? extends T>`。
- **Consumer Super (消费者使用 `super`)**: 如果你的泛型集合主要用于**写入/接收数据**（作为消费者），那么使用 `<? super T>`。

`<? extends T>` (上界通配符 - Upper Bounded Wildcard) 包括T在内的任何T的子类

`<? super T>` (下界通配符 - Lower Bounded Wildcard) 包括T在内的任何T的父类

### java中的String家族

`String`类具有不可变性，线程安全，对于字符串的拼接每次都需要新创对象，性能较差，有字符串常量池，帮助节省内存。java8之前是`char[]`，java9之后`byte[]+coder`。

`StringBuilder`类具有可变性，可以用 `append()`、`insert()`、`delete()` 等方法修改对象值而不新建对象，内部为一个可变的字符数组，线程不安全，适用于单线程场景。

`StringBuffer`类同样具有可变性，且线程安全，大多数方法都使用了`synchronized`关键字同步，由于同步操作的消耗，适用于多线程场景。

### java中的异常家族

```text
Throwable
├── Error（如 VirtualMachineError、OutOfMemoryError）
└── Exception
    ├── RuntimeException（如 NullPointerException、IllegalArgumentException）
    └── 检查异常（如 IOException、SQLException）
```

异常处理机制：

 try-catch-finally 块 与 方法后面的throws

异常主要分为两类：

- 未检查异常（unchecked exceptions）是继承自RuntimeException类或Error类的异常，编译器不强制要求进行异常处理。因此，对于这些异常，不需要在方法签名中使用throws来声明。
- 对于非检查异常，可以用try-catch包围且不需要方法后throws。

- 检查异常（checked exceptions） 除了未检查异常其他的类。java编译器会强制要求你必须处理这类异常。

- 对于检查异常，处理方法二选一：try-catch或方法后throws。

java中也可以通过继承 Exception 或 RuntimeException 创建自定义异常。

### java中的反射家族

Java 的反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。

反射具有以下特性：

1. 运行时类信息访问：反射机制允许程序在运行时**获取类的完整结构信息**，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。
2. 动态对象的创建：可以使用反射API动态地**创建对象实例**，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法（已废弃）或Constructor对象的newInstance()方法实现的。
3. 动态方法的调用：可以在运行时动态地**调用对象的方法**，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。
4. 访问和修改字段值：反射还允许程序在运行时**访问和修改对象的字段值**，即使是私有的。这是通过Field类的get()和set()方法完成的。

反射是作用在唯一的Class对象上。Class对象是类的元数据在JVM中的唯一表示，反射通过操作这个唯一的Class对象，得以动态地实例化出多个与该类类型相同的实例对象，这些实例对象是独立的，但都与同一个Class对象关联。

可以理解为：JVM在类加载拿到了蓝图之后，可以利用反射来源源不断地制造和蓝图相同的实例对象，且可以利用反射来调用方法、设置值、获取属性等。

java的反射机制主要应用场景：

- 开发框架：如Spring通过IoC控制反转利用反射创建Bean并DI注入依赖交由容器运行时使用。如碰到AOP相关注解时单独代理实例。
- 插件系统：根据配置加载未知的类。
- 序列化/反序列化：JSON的转换。
- 动态代理：实现AOP或拦截器。

### java中的注解家族

Java注解（Annotation）本质上是一种特殊的接口，它继承自 `java.lang.annotation.Annotation` 接口。注解本身并不直接影响代码的执行，而是作为一种元数据（metadata）嵌入到源代码、字节码或者在运行时被读取，为程序元素（如类、方法、字段等）提供额外的信息。这些信息可以被编译器、开发工具或运行时库所使用，以实现特定的功能。

当Java源代码被编译成字节码（`.class`文件）时，注解信息会根据其定义的保留策略被相应地处理。注解的生命周期由 `@Retention` 元注解指定：`RetentionPolicy.SOURCE` 表示注解仅保留在源代码中，编译时被丢弃；`RetentionPolicy.CLASS` 表示注解会被编译到字节码文件中，但在运行时对JVM不可见；而 `RetentionPolicy.RUNTIME` 则表示注解会被编译到字节码文件，并且在程序运行时可以被JVM加载和读取。在字节码文件中，这些运行时可见或不可见的注解信息会作为特定的属性（如 `RuntimeVisibleAnnotations` 或 `RuntimeInvisibleAnnotations`）存储起来。

在程序运行时，如果注解的保留策略是 `RUNTIME`，我们就可以通过Java的反射机制来获取这些注解信息。有趣的是，当我们通过反射API（例如 `Class.getAnnotation()` 或 `Method.getAnnotation()`）获取一个注解的实例时，Java虚拟机并不会直接创建一个实现了该注解接口的静态类实例。相反，JVM会动态地生成一个该注解接口的**代理类**实例。这个动态代理对象在被调用其定义的属性方法时，实际上会委托给一个名为 `AnnotationInvocationHandler` 的处理器。这个处理器会从一个内部的 `memberValues` 映射中查找并返回注解属性对应的值，而这些 `memberValues` 中的数据则来源于类加载时从字节码文件中解析出的注解属性数据，这些数据最初是在编译时从常量池和注解声明中固化的。

为了精确控制注解能够应用于哪些程序元素，Java提供了 `@Target` 元注解。通过 `@Target`，我们可以指定一个注解可以用于修饰类、接口、枚举、方法、字段、构造器、参数、局部变量等多种目标。因此，`@Retention` 决定了注解信息能保留到哪个阶段，而 `@Target` 则规定了注解可以“贴”在哪些地方，两者共同定义了注解的作用范围和实际应用场景。许多现代框架（如Spring）广泛利用运行时注解，通过反射读取这些元数据来驱动框架的自动化配置、依赖注入、行为拦截等动态功能。

### java的判断家族

java中存在三种方法来判断：

- `==` 对于基本数据类型，比较值是否相同；对于引用数据类型，比较两者引用是不是同一个地址值，即是否是同指向一个对象。 注意： `==`类型不兼容会报错，即 基本==基本或者引用==引用，特殊情况为 基本==包装类 会触发自动**拆箱**。
- `equals()`仅用于引用对象之间，比较两个对象的**内容**是否相等，当未被重写时行为与`==`相同。很多类重写了方法用于比较对象的内容。
- `hashCode()`返回对象的哈希码（一个整数），用于快速定位对象，默认基于内存地址，可被重写。

注意`equals()`与`hashCode()`必须同时重写，且要满足以下要求：

1. 一致性：如果 a.equals(b) 返回 true，则 a.hashCode() 必须等于 b.hashCode()。
2. 非对称性：如果 a.equals(b) 返回 false，a.hashCode() 和 b.hashCode() 可以相同（哈希冲突），但应尽量避免。
3. 稳定性：在一个对象的生命周期中，只要 equals 使用的属性未变，hashCode 必须始终返回相同值。

**相等的对象必须有相同的哈希码，但哈希码相同的对象不一定相等（equals）**。

对于哈希冲突可以应用

- 拉链法：将相同哈希码的对象放入同一个“桶”中，用链表（或类似结构）存储。如Java集合中的 HashMap 和 HashSet 。当相同哈希码数量过多时可以将链表转换为红黑树。
- 开放寻址法：在哈希表中找到另一个可用的位置来存储冲突的键值对，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列。
- 再哈希法（Rehashing）：当发生冲突时，使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对。
- 哈希桶扩容：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率。

### java的1.8版本

java的1.8版本引入很多有用工具：

- Lambda表达式：Lambda 表达式是一个**匿名函数**（没有名称的函数），可以将其理解为一段可以传递的代码块。**它通常用来实现函数式接口（只有一个抽象方法的接口）的行为。**Lambda 表达式通过简洁的语法替代了传统的匿名内部类，使代码更简洁、可读性更高。格式为：(参数) -> 主体 。
- 函数式接口：只有一个抽象方法的接口，可与 Lambda 配合使用，如`Predicate<Integer> isEven = n -> n % 2 == 0;`

- Stream API：对集合进行函数式操作，支持过滤、映射、归约等。
- 方法引用：用 `::` 简化 Lambda 表达式，引用已有方法，而不是提供一个Lambda表达式来调用它。 当你想要执行的Lambda表达式的主体恰好已经有一个现成的方法可以完成时，使用方法引用可以让代码更简洁、可读性更高。
- Base64编解码工具：如`Base64.getEncoder().encodeToString("text".getBytes());`

对于Lambda与函数式接口与方法引用：

```java
interface Dog {
    abstract void eat();
}

// 辅助类，包含一个静态方法
class DogActivities {
    public static void performStaticEat() {
        System.out.println("狗狗通过[静态方法引用]正在优雅地进食...");
    }
}

class Main {
    public static void main(String[] args) { 
        // 1. 匿名内部类实现
        Dog dogAnonymous = new Dog() {
            @Override
            public void eat() {
                System.out.println("我是通过匿名内部类实现的 eat 方法");
            }
        };
        dogAnonymous.eat();

        // 2. Lambda表达式实现
        Dog dogLambda = () -> {
            int b = 3; // Lambda可以有多行语句
            System.out.println("Lambda说：小狗吃了 " + b + " 块饼干");
        };
        dogLambda.eat();

        // 3. 方法引用 :: (引用静态方法)
        // DogActivities::performStaticEat 指向 DogActivities 类的静态方法 performStaticEat
        Dog dogStaticMethodRef = DogActivities::performStaticEat;
        dogStaticMethodRef.eat(); // 调用时会执行 DogActivities.performStaticEat()
    }
}
```

对于Stream API：它提供了一种声明式的方式来操作数据，支持过滤、映射、排序、归约等操作，并且可以轻松实现并行处理。

Stream的特点：

- 惰性求值，中间的操作不会立刻执行，只有遇到终端操作时才会触发计算。
- 一次性使用，Stream只能消费一次。
- 可以通过`parallelStream()` 或` parallel() `方法轻松实现并行处理。

Stream 的三个阶段：

- 创建：从数据源生成Stream。
- 中间操作：对数据进行操作返回新的Stream（包含了相关的操作逻辑）。
- 终端操作：触发执行并产生最终结果，关闭Stream。

如何创建Stream流：

1. 从集合创建

```java
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream = list.stream();         // 串行流
Stream<String> parallelStream = list.parallelStream(); // 并行流
```

2. 从数组创建

```java
String[] array = {"a", "b", "c"};
Stream<String> stream = Arrays.stream(array);
```

3. 直接创建

```java
Stream<Integer> stream = Stream.of(1, 2, 3, 4);从文件或I/O创建
```

4. 从文件或者I/O创建

```java
try (Stream<String> lines = Files.lines(Paths.get("file.txt"))) {
    lines.forEach(System.out::println);
} catch (IOException e) {
    e.printStackTrace();
}
```

5. 创建无限流

- `Stream.iterate()`：生成无限序列。
- `Stream.generate()`：通过 Supplier 生成。

```java
Stream<Integer> infinite = Stream.iterate(0, n -> n + 1); // 0, 1, 2, ...
Stream<Double> randoms = Stream.generate(Math::random);   // 随机数流
```

Stream API 的方法

中间操作：

| **方法**           | **描述**                       | **示例**                                 |
| ------------------ | ------------------------------ | ---------------------------------------- |
| filter(Predicate)  | 过滤符合条件的元素             | stream.filter(x -> x > 0)                |
| map(Function)      | 将元素映射为新值               | stream.map(String::toUpperCase)          |
| flatMap(Function)  | 将每个元素映射为一个流并扁平化 | stream.flatMap(x -> Stream.of(x, x+1))   |
| distinct()         | 去除重复元素                   | stream.distinct()                        |
| sorted()           | 按自然顺序排序                 | stream.sorted()                          |
| sorted(Comparator) | 按指定比较器排序               | stream.sorted(Comparator.reverseOrder()) |
| limit(long)        | 限制返回元素数量               | stream.limit(3)                          |
| skip(long)         | 跳过前 n 个元素                | stream.skip(2)                           |
| peek(Consumer)     | 查看元素（调试用），不改变流   | stream.peek(System.out::println)         |

终端操作

| **方法**                  | **描述**                                 | **示例**                            |
| ------------------------- | ---------------------------------------- | ----------------------------------- |
| forEach(Consumer)         | 对每个元素执行操作                       | stream.forEach(System.out::println) |
| collect(Collector)        | 将流收集为集合或其他结构                 | stream.collect(Collectors.toList()) |
| reduce(T, BinaryOperator) | 归约操作，合并元素为单一结果             | stream.reduce(0, Integer::sum)      |
| count()                   | 返回流中元素数量                         | stream.count()                      |
| anyMatch(Predicate)       | 检查是否至少有一个元素满足条件           | stream.anyMatch(x -> x > 0)         |
| allMatch(Predicate)       | 检查是否所有元素都满足条件               | stream.allMatch(x -> x > 0)         |
| noneMatch(Predicate)      | 检查是否没有元素满足条件                 | stream.noneMatch(x -> x < 0)        |
| findFirst()               | 返回第一个元素（Optional）               | stream.findFirst()                  |
| findAny()                 | 返回任意一个元素（Optional，适合并行流） | stream.findAny()                    |
| toArray()                 | 将流转换为数组                           | stream.toArray(String[]::new)       |

**并行流（Parallel Stream）** 是 Stream API 提供的一种功能，允许通过多线程并行处理数据，以充分利用多核处理器的计算能力，从而提高性能。可用 parallel() 方法将普通流转换为并行流。通过Fork/Join框架和线程池来确保运行。

### java的序列化与反序列化

要在不同的Java虚拟机（JVM）之间传递对象，我们不能直接共享内存中的对象，因为每个JVM都有其独立的内存空间。因此，核心方法是将对象的状态转换为一种可传输的数据格式，这个过程称为序列化；数据传输到目标JVM后，再从这种数据格式恢复成对象，即反序列化。这种机制使得对象的状态得以跨越JVM边界。

虽然Java本身提供了基于`java.io.Serializable`接口的内置序列化机制，它能将对象直接转换为字节流，但在许多现代应用中，开发者更倾向于使用更为通用和灵活的文本格式，特别是JSON。JSON格式因其轻量级和良好的可读性而广泛流行。主流的Java库如**Jackson**和**Fastjson**，它们能够非常方便地将Java对象序列化为JSON字符串，以及从JSON字符串反序列化回Java对象，这使得对象的数据表示不仅易于调试，也便于跨语言系统间的交互。

当一个对象被序列化成JSON字符串（或其他选定格式）后，这个字符串数据就可以通过网络从源JVM发送到目标JVM。常见的传输方式包括通过HTTP/HTTPS协议构建RESTful API接口，其中JSON作为请求体或响应体的内容；或者利用消息队列（如Kafka、RabbitMQ），将序列化后的对象数据作为消息进行异步传递。一旦目标JVM接收到这个JSON字符串，它会使用相应的库（如Jackson或Fastjson）进行反序列化，依据字符串内容在本地内存中重建Java对象。当然，为了成功反序列化，目标JVM的类路径下必须包含该对象的类定义，并且该类结构需要与JSON数据能够兼容。

### **java的I/O家族**

Java的I/O（输入/输出）机制是其核心功能之一，允许程序与外部世界（如文件系统、网络连接、其他程序等）进行数据交换。Java I/O体系结构设计得相当灵活，主要围绕“流”（Stream）的概念构建，使得开发者可以组合不同的流类来实现复杂的I/O操作。

早期的Java I/O（通常称为BIO，Blocking I/O）主要分为两大类：字节流和字符流。

- **字节流家族**以`InputStream`和`OutputStream`为基类，它们直接操作8位的字节数据，非常适合处理二进制文件（如图片、音频、视频）或任何原始字节序列。常用的实现类包括用于文件操作的`FileInputStream`和`FileOutputStream`，用于提升性能的缓冲流`BufferedInputStream`和`BufferedOutputStream`，以及能够读写Java基本数据类型和对象的`DataInputStream`/`DataOutputStream`与`ObjectInputStream`/`ObjectOutputStream`（这与你之前总结的序列化紧密相关）。

- **字符流家族**，其基类为`Reader`和`Writer`。字符流操作16位的Unicode字符数据，并且能够自动处理字符集编码和解码，因此更适合处理文本文件。常见的字符流包括直接操作文件的`FileReader`和`FileWriter`（它们使用平台默认字符集），以及非常重要的桥接流`InputStreamReader`（将字节输入流转换为字符输入流）和`OutputStreamWriter`（将字符输出流转换为字节输出流），这两者允许在转换时显式指定字符编码。为了提高读写效率和提供更便捷的文本行操作，`BufferedReader`（提供了`readLine()`方法）和`BufferedWriter`，以及格式化输出的`PrintWriter`也经常被使用。

从Java 1.4开始，引入了

- NIO（New I/O，或Non-blocking I/O），位于`java.nio`包下。通常被描述为一种同步非阻塞的I/O模型。NIO的核心在于其三大组件：**通道（Channels）**、**缓冲区（Buffers）和选择器（Selectors）**。NIO的**通道**代表了与I/O设备（如文件、套接字）的连接，数据通过通道传输，并且通道可以被设置为非阻塞模式。这意味着当执行读写操作时，如果数据没有准备好或无法立即写入，操作会马上返回，而不是让线程阻塞。数据传输则依赖**缓冲区**，这是一块内存区域，数据从通道读入缓冲区或从缓冲区写入通道。实现高效I/O多路复用的关键是**选择器**。它允许单个线程监控多个通道的I/O事件（如连接、读就绪、写就绪）。应用程序将通道注册到选择器上，并指定感兴趣的事件。然后，线程调用选择器的`select()`方法，该方法会阻塞直到至少一个注册的通道上发生了感兴趣的事件（或超时）。此时，`select()`方法返回，线程可以获取就绪通道的集合，并对这些通道进行相应的（通常是非阻塞的）I/O操作。这种机制的底层依赖于操作系统提供的I/O多路复用功能（如`epoll`、`kqueue`），使得一个线程能有效地管理大量并发连接，大大减少了线程数量和上下文切换的开销，提高了系统的伸缩性。

随后，Java 7进一步增强了I/O能力，引入了

- NIO.2，其核心改进主要体现在`java.nio.file`包中。NIO.2提供了一套更为现代化和强大的文件系统API，其核心类包括`Path`（用于表示文件或目录的路径）、`Paths`（创建`Path`实例的工厂类）和`Files`（包含大量用于操作文件和目录的静态实用方法）。NIO.2支持更细致的文件属性访问、符号链接操作、文件树遍历以及通过`WatchService`监视目录变化等高级功能，从而在很大程度上取代了老旧且功能相对局限的`java.io.File`类。

关于不同I/O模型的区别，可以这样理解：

**BIO（Blocking I/O）**，即传统的`java.io`包，它基于流模型实现，交互方式是同步阻塞的。这意味着在读写操作完成前，执行线程会一直阻塞，调用顺序是可靠的线性序列。其优点是代码简单直观，缺点则是I/O效率和扩展性较低，容易成为应用性能的瓶颈。

**NIO（Non-blocking I/O）**，由Java 1.4引入的`java.nio`包，提供了通道、选择器、缓冲区等新抽象，用以构建多路复用的、同步非阻塞的I/O程序。NIO提供了更接近操作系统底层的高性能数据操作方式，允许单线程管理多个连接。

而**AIO（Asynchronous I/O）**，自Java 1.7（作为NIO.2的一部分）引入，通常被认为是NIO的进一步升级。它提供了异步非阻塞的I/O操作方式。异步I/O基于事件和回调机制实现：应用程序发起I/O操作后会立即返回而不会阻塞，当后台I/O处理完成后，操作系统会通知相应的线程（例如通过回调函数）进行后续操作。

## java的集合框架

集合与数组的区别：

数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素。

数组可以包含基本数据类型和对象，而集合只能包含对象。数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。

集合中的顶级接口是Collection，和Collections类的区别：

Collection是Java集合框架中的一个接口，它是所有集合类的基础接口。它定义了一组通用的操作和方法，如添加、删除、遍历等，用于操作和管理一组对象。

Collections（注意有一个s）是Java提供的一个工具类，位于java.util包中。它提供了一系列静态方法，用于对集合进行操作和算法。Collections类中的方法包括排序、查找、替换、反转、随机化等等。这些方法可以对实现了Collection接口的集合进行操作，如List和Set。

对于集合中的元素的遍历可以有以下几种方法：

for循环、增强for、for-each、Iterator迭代器 、Stream API

### java的集合家族

![img](https://cdn.nlark.com/yuque/0/2025/png/50462032/1747393405064-997cd12b-7241-489b-b068-5e95f0217f59.png)

#### List

##### Vector

- 线程安全（方法几乎全用 `synchronized`关键字修饰） 。
- 底层结构 动态数组（`Object[]`），可以根据需要自动的增加容量，当数组已满时，会创建新的数组（增加一倍），并拷贝原有数组数据。
- FILO队列。可以模拟栈队列。

##### Stack extends Vector

- 线程安全。
- 底层结构 动态数组（`Object[]`）扩容增加一倍。
- FILO。
- 专门提供了更清晰的 LIFO 语义。（`push()`、`pop()`、`peek()`、`empty()`等）。

##### ArrayList

- 线程不安全。
- 底层结构 动态数组（`Object[]`）。
- 数组实现 一般扩容1.5倍。先计算容量，创建一个新数组，将内容复制后更改引用。
- 基于索引的访问效率高。在列表末尾添加删除元素很快。中间操作会导致后续元素移动时间复杂度O(n)。随机删除很快。
- 经常会出null问题索引越界问题。

##### CopyOnWriteArrayList

- 线程安全
- 底层结构 动态数组（`Object[]`）
- 工作原理：读取操作时，直接访问。写操作时，先获取内部锁（`ReentrantLock`），复制当前数组，创建一个新数组（长度加1），在新数组上操作，将内部数组引用指向这个新数组，最后释放锁。

##### LinkedList

- 线程不安全。
- 双向链表结构 不需要扩容。
- 头尾增删改效率高，随机查询效率低。随机删除要先遍历。
- 可以用作队列或者栈使用。

#### Set

##### HashSet

- 特点：元素唯一，**无序**。

- 实现：基于哈希表。

- 适用场景：当你只需要保证元素唯一，而不关心元素的排列顺序，并且追求高效率时。

##### LinkedHashSet

- 特点：元素唯一，**保持插入顺序**。
- 实现：基于哈希表和双向链表。
- 适用场景：当你既需要保证元素唯一，又需要记录元素被添加进集合的先后顺序时。

##### TreeSet

- 特点：元素唯一，**按元素的自然顺序或自定义比较器顺序排序**。
- 实现：基于红黑树。
- 适用场景：当你需要一个自动排序的、元素唯一的集合时。

##### Set集合有什么特点？如何实现key无重复的？

- **set集合特点**：Set集合中的元素是唯一的，不会出现重复的元素。
- **set实现原理**：Set集合通过内部的数据结构（如哈希表、红黑树等）来实现key的无重复。当向Set集合中插入元素时，会先根据元素的hashCode值来确定元素的存储位置，然后再通过equals方法来判断是否已经存在相同的元素，如果存在则不会再次插入，保证了元素的唯一性。

##### 有序的Set是什么？记录插入顺序的集合是什么？

- **有序的 Set 是TreeSet和LinkedHashSet**。TreeSet是基于红黑树实现，保证元素的自然顺序。LinkedHashSet是基于双重链表和哈希表的结合来实现元素的有序存储，保证元素添加的自然顺序
- **记录插入顺序的集合通常指的是LinkedHashSet**，它不仅保证元素的唯一性，还可以保持元素的插入顺序。当需要在Set集合中记录元素的插入顺序时，可以选择使用LinkedHashSet来实现。

#### Queue

`Queue`（队列）接口是 Java 集合框架的一部分，它继承自 `Collection` 接口，主要用于实现在处理元素前保存元素的集合，通常（但不一定）以 **FIFO（First-In, First-Out，先进先出）** 的方式对元素进行排序。这意味着元素通常从队列的一端（尾部）插入，从另一端（头部）移除。

##### Deque

- `Deque`（Double Ended Queue，双端队列）接口继承自 `Queue` 接口，它支持在队列的两端进行元素的插入和移除操作。因此，`Deque` 既可以作为标准的 FIFO 队列使用，也可以作为 **LIFO（Last-In, First-Out，后进先出）的栈**使用。
- 可头插 `offerFirst() / addFirst()` 移除`removeFirst() / pollFirst()`检查`getFirst() / peekFirst()`
- 尾部插 `offerLast() / addLast()` 移除`removeLast() / pollLast()`检查`getLast() / peekLast()`

##### PriorityQueue

- `PriorityQueue` 是一种特殊的队列，它不遵循严格的 FIFO 原则，而是根据元素的**优先级**进行出队操作。每次调用 `poll()` 或 `remove()` 方法时，都会移除并返回优先级最高的元素。

- 底层通常基于**二叉堆（binary heap）实现。默认情况下，它是一个最小堆 (min-heap)**，即优先级最高的元素是值最小的元素。可以通过在构造时传入自定义的 `Comparator` 来实现最大堆 (max-heap) 或其他自定义优先级规则。

- `add()` 或 `offer()` 方法用于添加元素，时间复杂度为 O(log n)。

  `poll()` 或 `remove()` 方法用于移除并返回优先级最高的元素，时间复杂度为 O(log n)。

  `peek()` 方法用于查看优先级最高的元素但不移除，时间复杂度为 O(1)。

  线程不安全。

  不允许存储 `null` 元素。

  允许存储重复元素，但它们的相对顺序（如果优先级相同）未定义。

### java的Map家族

![img](https://cdn.nlark.com/yuque/0/2025/png/50462032/1747393472616-508d40d8-f84c-48e0-b616-3d406b7b5cf1.png)

#### Map

##### HashMap

`HashMap` 内部使用一个数组（通常称为“桶数组”或 "hash table"）来存储键值对（Entry）。

- 线程不安全 多线程可能发生的问题：如果多线程计算出元素索引位置相同会出现覆盖导致丢失。以及JDK1.8之前通过头插法会造成死循环。
- 底层：JDK1.8之前是：数组+链表 更新后：数组+链表，当链表过长（8个）时转为红黑树。
- 初始容量16 为什么是2的n次方：扩容时，新数组的容量依然是旧数组的两倍，但元素在新数组中的位置判断更为巧妙，系统不再为每个元素重新计算完整的哈希索引，而是通过检查元素哈希值的某一个特定二进制位（具体是 `hash & 旧容量` 的结果）。若该特定位为0，则元素在新数组中的索引与旧索引保持一致；若为1，则新索引为“原索引 + 旧数组容量”。这样，原先一个桶中的元素会被高效地、且保持相对顺序地分配到新数组的两个确定位置中，减少了计算开销并改善了哈希冲突的分布。
- 一般用String做Key，不能被修改保证Key的稳定性，可变的Key可能会导致hashCode和equals方法不一致。Key可以为Null 直接会令哈希为0，且只能有一个，Value可以有多个Null。
- HashMap会使用Key对象的hashCode()和equals方法去决定key-value对的索引以及取Value，要注意重写equals和hashCode方法：
  - 如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。
  - 如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。
- 存入元素：HashMap通过哈希算法将元素的键（Key）映射到数组中的槽位（Bucket）。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上。当同一个槽位的元素过多时，转为红黑树。小于6时转回链表。具体过程：
  - `HashMap` 首先调用 **`key` 对象**的 `hashCode()` 方法，得到一个整数哈希码。再计算这个哈希码所映射到数组的索引位置（桶的索引值）。
  - 如果没元素，则直接在该位置创建一个新的Entry对象来存储键值对。将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置。将HashMap的修改次数（modCount）加1，以便在进行迭代时发现并发修改。
  - 如果该位置有元素 调用**`key` 对象**的 `equals()` 方法，如果找到一个 `equals()` 返回 `true` 的 `key`，那么就认为这个 `key` 已经存在，新的 `value` 会覆盖旧的 `value`。
  - 如果第一个键值对的哈希码和键不相同，则需要遍历链表或红黑树来查找是否有相同的键。**如果是链表**：从链表的头部开始逐个比较键的哈希码和equals()方法，直到找到相同的键或达到链表末尾。找到就替换，没找到，则将新的键值对添加到链表的**头部**。**如果是红黑树**：在红黑树中使用哈希码和equals()方法进行查找。根据键的哈希码，定位到红黑树中的某个节点，然后逐个比较键，直到找到相同的键或达到红黑树末尾。找到就替换，找不到就添加到红黑树中。
  - 检查长度阈值：链表与红黑树转换
  - 检查负载因子是否超过阈值（0.75）：如果键值对的数量（size）与数组的长度的比值大于阈值，则需要进行扩容操作。扩容：
    - 第一步将哈希表扩容，成原来的2倍。
    - 第二步将旧哈希表中的数据放到新的哈希表中。（原位置或者移动2次幂的位置）
    - 为什么选0.75？经验值与统计学，在理想情况下（哈希函数能将元素均匀分布），当加载因子为 `α`时，一个桶中元素的数量可以近似看作服从参数为 `α`的泊松分布。
    - 例子：

“苹果的哈希码是5”，“香蕉的哈希码是21”时，指的是它们的**原始哈希码**。

- **苹果：** 原始哈希码是5。在16个桶的系统里，它的桶编号是 `5 & 15 = 5`。(这里的15就是 n-1)
- **香蕉：** 原始哈希码是21。在16个桶的系统里，它的桶编号是 `21 & 15 = 5`。

所以，它们俩因为各自不同的原始哈希码（5 和 21），恰好都进入了编号为5的桶，并在这个桶里形成了链表。

在达到0.75因子之后扩容 原本16个桶位变成了32个桶 怎么把他们分过去呢？利用新加一位的按位与

苹果 0000 0101 (hash)

香蕉 0001 0101 (hash)

他们在扩容之前在哪个桶？

n-1        0000  1111& =>0000 0101 (第5号桶)

苹果       0000 0101

n-1        0000  1111& =>0000 0101 (第5号桶)

香蕉       0001 0101

他们扩容之后呢

n-1        0001  1111& =>0000 0101 (第5号桶)

苹果      0000 0101

n-1        0001  1111& =>0001 0101 (第21号桶)

香蕉      0001 0101

##### LinkedHashMap

- 线程不安全
- 底层：双向链表

##### TreeMap

- 线程不安全
- 底层：红黑树，可以对键进行排序默认按照自然顺序排序。

##### HashTable

- HashTable是线程安全的，实现方式是所有公共方法均采用synchronized关键字。
- 默认容量11 每次扩容到之前的`2n+1`。
- Hashtable的底层数据结构主要是**数组加上链表**，数组是主体，链表是解决hash冲突存在的。

##### ConcurrentHashMap

- 线程安全 JDK1.8以前：分段锁：数据被分为多个`Segment`每个段都有自己的锁，可允许多个线程操作不同的段，提高并发效率。 JDK1.8：volatile + CAS 或者 synchronized。
- 在 JDK 1.7 中它使用的是数组加链表的形式，而数组又分为：大数组 Segment 和小数组 HashEntry。 Segment是一种可重入锁（ReentrantLock），在 ConcurrentHashMap 里扮演锁的角色；HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。
-  JDK 1.8 则使用了数组 + 链表/红黑树的方式优化了 ConcurrentHashMap 的实现
- JDK1.8时添加数据：首先会判断容器是否为空，如果为空则使用 volatile 加 CAS 来初始化，如果容器不为空，则根据存储的元素计算该位置是否为空。如果根据存储的元素计算结果为空，则利用 CAS 设置该节点；如果根据存储的元素计算结果不为空，则使用 synchronized ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。

#### Map的遍历方法

- for-each + entrySet() 方法 同时获取Map中的键和值。

```java
// 使用for-each循环和entrySet()遍历Map
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
        }
```

- 使用for-each循环和keySet()方法 

```java
// 使用for-each循环和keySet()遍历Map的键
        for (String key : map.keySet()) {
            System.out.println("Key: " + key + ", Value: " + map.get(key));
        }
```

- 使用迭代器

```java
 // 使用迭代器遍历Map
        Iterator<Entry<String, Integer>> iterator = map.entrySet().iterator();
        while (iterator.hasNext()) {
            Entry<String, Integer> entry = iterator.next();
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
        }
```

- 使用 Lambda 表达式和forEach()方法

```java
// 使用Lambda表达式和forEach()方法遍历Map
        map.forEach((key, value) -> System.out.println("Key: " + key + ", Value: " + value));
```

#### HashMap和Hashtable、ConcurrentMap的区别

- HashMap线程不安全，效率高一点，可以存储null的key和value，null的key只能有一个，null的value可以有多个。默认初始容量为16，每次扩充变为原来2倍。创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。
- HashTable线程安全，效率低一点，其内部方法基本都经过synchronized修饰，不可以有null的key和value。默认初始容量为11，每次扩容变为原来的2n+1。创建时给定了初始容量，会直接用给定的大小。底层数据结构为数组+链表。它基本被淘汰了，要保证线程安全可以用ConcurrentHashMap。
- ConcurrentHashMap是Java中的一个线程安全的哈希表实现，它可以在多线程环境下并发地进行读写操作，而不需要像传统的HashTable那样在读写时加锁。ConcurrentHashMap的实现原理主要基于分段锁和CAS操作。它将整个哈希表分成了多Segment（段），每个Segment都类似于一个小的HashMap，它拥有自己的数组和一个独立的锁。在ConcurrentHashMap中，读操作不需要锁，可以直接对Segment进行读取，而写操作则只需要锁定对应的Segment，而不是整个哈希表，这样可以大大提高并发性能。

### java常用集合代码段

| 数据结构      | 底层实现 | 顺序性 | 重复性 | 线程安全 | 主要操作复杂度       | 典型用途       |
| ------------- | -------- | ------ | ------ | -------- | -------------------- | -------------- |
| ArrayList     | 动态数组 | 有序   | 可重复 | 否       | 访问 O(1), 增删 O(n) | 动态列表       |
| LinkedList    | 双向链表 | 有序   | 可重复 | 否       | 头尾 O(1), 访问 O(n) | 队列、双端操作 |
| Stack         | 动态数组 | LIFO   | 可重复 | 是       | 顶部 O(1)            | 栈操作         |
| ArrayDeque    | 循环数组 | 双端   | 可重复 | 否       | 头尾 O(1)            | 栈/队列替代    |
| HashSet       | 哈希表   | 无序   | 无重复 | 否       | 平均 O(1)            | 去重           |
| TreeSet       | 红黑树   | 有序   | 无重复 | 否       | O(log n)             | 排序集合       |
| HashMap       | 哈希表   | 无序   | 键唯一 | 否       | 平均 O(1)            | 键值映射       |
| TreeMap       | 红黑树   | 有序   | 键唯一 | 否       | O(log n)             | 排序映射       |
| PriorityQueue | 二叉堆   | 优先级 | 可重复 | 否       | 增删 O(log n)        | 优先级任务     |

````java
List<Integer> list = new ArrayList<>(); //动态数组
add() remove() indexOf() contains() size()

Queue<Integer> queue = new LinkedList<>();//双向链表 先进先出
offer() poll() peek() contains() size()

Stack<Integer> stack = new Stack<>();//动态数组 先进后出
push() pop() peek() size()

Deque<Integer> deque = new ArrayDeque<>();//循环数组 可选两头出入
offer() offerFirst/Last() pool() pollFirst/Last() peek() peekFirst/Last()  size()

Set<Integer> hashSet = new HashSet<>();//哈希表
add() remove() contains() size()

Set<Integer> treeSet = new TreeSet<>(); //红黑树 TreeSet 默认按自然顺序（升序）排序
add() remove() contains() size() first() last()

Map<Integer,Integer> hashMap = new HashMap<>();//哈希表
put() remove() get() containsKey() containsValue() size()

Map<Integer,Integer> treeMap = new TreeMap<>();//红黑树 TreeMap 默认按自然顺序（升序）排序
put() remove() get() containsKey() containsValue() size() firstKey() lastKey()

PriorityQueue<Integer> pq = new PriorityQueue<>();
//二叉堆(默认最小堆，可自定义 Comparator 实现最大堆）
//进出顺序：按优先级出队（默认升序，最小元素先出）
offer() add() poll() remove() peek() contains() size()
````

## java的高效家族：JUC

JUC通常指`java.util.concurrent`包。

注：Java 底层会调用 pthread_create 来创建线程，所以本质上 java 程序创建的线程，就是和操作系统线程是一样的，是 1 对 1 的线程模型。

使用多线程就要注意线程安全问题，Java的线程安全在三个方面体现：

- **原子性**：提供互斥访问，**同一时刻只能有一个线程对数据进行操作**，在Java中使用了atomic包（这个包提供了一些支持原子操作的类，这些类可以在多线程环境下保证操作的原子性）和synchronized关键字来确保原子性；
- **可见性**：一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了synchronized和volatile这两个关键字确保可见性；
- **有序性**：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。

保证数据一致性的方案：

- **事务管理**：使用数据库事务来确保一组数据库操作要么全部成功提交，要么全部失败回滚。通过ACID（原子性、一致性、隔离性、持久性）属性，数据库事务可以保证数据的一致性。
- **锁机制**：使用锁来实现对共享资源的互斥访问。在 Java 中，可以使用 synchronized 关键字、ReentrantLock 或其他锁机制来控制并发访问，从而避免并发操作导致数据不一致。
- **版本控制**：通过乐观锁的方式，在更新数据时记录数据的版本信息，从而避免同时对同一数据进行修改，进而保证数据的一致性。

### 线程池

线程池是为了减少频繁的创建线程和销毁线程带来的性能损耗，线程池分为核心线程池，线程池的最大容量，还有等待任务的队列，提交一个任务，如果核心线程没有满，就创建一个线程，如果满了，就是会加入等待队列，如果等待队列满了，就会增加线程，如果达到最大线程数量，如果都达到最大线程数量，就会按照一些丢弃的策略进行处理。

```text
提交任务 → 核心线程是否已满？
  ├─ 未满 → 创建核心线程执行
  └─ 已满 → 任务入队
       ├─ 队列未满 → 等待执行
       └─ 队列已满 → 创建非核心线程
           ├─ 未达最大线程数 → 执行任务
           └─ 已达最大线程数 → 执行拒绝策略
```

```java
new ThreadPoolExecutor(
    16,                     // corePoolSize = 16（假设8核CPU × 2）
    32,                     // maximumPoolSize = 32（突发流量扩容）
    10, TimeUnit.SECONDS,   // 非核心线程空闲10秒回收
    new SynchronousQueue<>(), // 不缓存任务，直接扩容线程
    Executors.defaultThreadFactory(),//线程工厂。用于创建新线程。
    new AbortPolicy()       // 直接拒绝，避免系统过载
);
```

线程池的构造函数有7个参数：

- **corePoolSize**：线程池核心线程数量。默认情况下，线程池中线程的数量如果 <= corePoolSize，那么即使这些线程处于空闲状态，那也不会被销毁。
- **maximumPoolSize**：线程池中最多可容纳的线程数量。当一个新任务交给线程池，如果此时线程池中有空闲的线程，就会直接执行，如果没有空闲的线程且当前线程池的线程数量小于maximumPoolSize，就会创建新的线程来执行任务，否则就会将该任务加入到阻塞队列中，如果阻塞队列满了，就会创建一个新线程，从阻塞队列头部取出一个任务来执行，并将新任务加入到阻塞队列末尾。如果当前线程池中线程的数量等于maximumPoolSize，就不会创建新线程，就会去执行拒绝策略。
- **keepAliveTime**：当线程池中线程的数量大于corePoolSize，并且某个线程的空闲时间超过了keepAliveTime，那么这个线程就会被销毁。
- **unit**：就是keepAliveTime时间的单位。
- **workQueue**：工作队列。当没有空闲的线程执行新任务时，该任务就会被放入工作队列中，等待执行。
- **threadFactory**：线程工厂。可以用来给线程取名字等等
- **handler**：拒绝策略。当一个新任务交给线程池，如果此时线程池中有空闲的线程，就会直接执行，如果没有空闲的线程，就会将该任务加入到阻塞队列中，如果阻塞队列满了，就会创建一个新线程，从阻塞队列头部取出一个任务来执行，并将新任务加入到阻塞队列末尾。如果当前线程池中线程的数量等于maximumPoolSize，就不会创建新线程，就会去执行拒绝策略。

#### 线程池的五种状态

1. running

线程池正常运行 既能接受新任务 也会处理队列中的任务

2. shutdown

调用线程池的shutdown()方法 线程池进入shutdown状态 不会接受新任务 但是会完成队列中的任务

3. stop

调用线程池的shutdownnow()方法 线程池进入stop状态 不会接受新任务 也不会完成队列中的任务 正在运行的线程也会被中断

4. tidying

没有线程运行的状态 线程池内部会调用terminated() 这个是空方法 可以自定义

5. terminated

terminated()方法调用后线程池状态

#### CompletableFuture

`CompletableFuture` 的核心思想是提供一种非阻塞的方式来处理异步计算的结果。传统的 `Future` 在获取结果时通常需要调用 `get()` 方法，而这个方法会阻塞当前线程直到异步计算完成。`CompletableFuture` 通过回调机制解决了这个问题，允许你在异步任务完成时自动执行某些操作，而无需阻塞主线程。

| 特性           | `Future`                             | `CompletableFuture`                                          |
| -------------- | ------------------------------------ | ------------------------------------------------------------ |
| **获取结果**   | 通常通过阻塞的 `get()` 方法获取。    | 可以通过非阻塞的回调机制处理结果，也支持 `get()`（但不推荐）。 |
| **任务编排**   | 功能非常有限，难以组合多个异步任务。 | 提供了丰富的 API 用于任务的串行、并行组合、选择等。          |
| **异常处理**   | 异常在调用 `get()` 时抛出。          | 提供了 `exceptionally`、`whenComplete` 等方法进行更灵活的异常处理。 |
| **显式完成**   | 无法从外部显式完成一个 `Future`。    | 可以通过 `complete()` 或 `completeExceptionally()` 方法从外部完成。 |
| **回调支持**   | 不直接支持回调。                     | 核心特性之一，可以在任务完成时自动触发后续操作。             |
| **函数式编程** | API 设计不符合现代函数式编程风格。   | 大量使用函数式接口，使得代码更简洁、易于理解和组合。         |

```java
    //线程池执行器
	@Bean
    public ThreadPoolExecutor threadPoolExecutor() {

        //动态获取服务器核数
        int processors = Runtime.getRuntime().availableProcessors();
        //Runtime.getRuntime(): 获取当前的Java运行时环境。
        //availableProcessors(): 返回Java虚拟机（JVM）可用的处理器核心数。这个数字通常等于操作系统的物理核心数或超线程环境下的逻辑核心数。
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                processors+1, // 核心线程个数 io:2n ,cpu: n+1  n:内核数据
                //CPU密集型任务 (cpu: n+1): 对于主要进行计算、消耗CPU资源的任务，通常建议将线程数设置为 N+1 或 N（N是CPU核心数）。N+1 的好处是即使有一个线程因为页错误或其他原因偶尔阻塞，CPU也能保持忙碌。你的代码采纳了这个策略。
                //I/O密集型任务 (io:2n): 对于主要进行I/O操作（如网络请求、文件读写）的任务，线程大部分时间在等待I/O完成，CPU是空闲的。因此可以设置更多的线程，比如 2N，以充分利用CPU。你的代码没有直接使用2n作为核心线程数，而是选择了n+1。
                processors+1,//最大线程数
                0,//线程空闲存活时间。当线程池中的线程数量超过corePoolSize时，如果一个线程的空闲时间达到了keepAliveTime，那么多余的空闲线程将被终止，直到线程数回落到corePoolSize。
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(3),//这是一个有界阻塞队列，基于数组实现，容量为3。这意味着这个队列最多只能存放3个等待执行的任务。
                Executors.defaultThreadFactory(),//线程工厂。用于创建新线程。Executors.defaultThreadFactory()会创建普通的、非守护（non-daemon）线程，并为它们设置一个标准的名称（如 pool-X-thread-Y）。
                new ThreadPoolExecutor.AbortPolicy()//拒绝策略（饱和策略）。当线程池和工作队列都满了（即无法再接收新任务）时，如何处理新提交的任务
            //ThreadPoolExecutor.AbortPolicy(): 这是默认的拒绝策略。它会直接抛出RejectedExecutionException运行时异常，从而中断调用者的执行。
        );
        return threadPoolExecutor;

    }
```

```java
        //定义多线程方法
		CompletableFuture<X> future1 = CompletableFuture.supplyAsync(() -> {
            ......
            return X;
        });
        CompletableFuture<Y> future2 = CompletableFuture.supplyAsync(() -> {
            ......
            return Y;
        });
        CompletableFuture<Z> future2 = CompletableFuture.supplyAsync(() -> {
            ......
            return Z;
        });
		//开启多线程任务
		CompletableFuture.allOf(
            future1,
            future2,
            future3
        ).join();
```

#### CPU/IO密集型

**CPU密集型 (CPU-Bound)**: 任务大部分时间都在进行计算，几乎不怎么等待外部资源（如磁盘、网络）。CPU利用率高。 一般n+1线程

**I/O密集型 (I/O-Bound)**: 任务大部分时间都在等待I/O操作完成（例如，读取文件、发送网络请求）。CPU在等待期间是空闲的。 一般2n线程

#### 线程池种类

- ScheduledThreadPool：可以设置定期的执行任务，它支持定时或周期性执行任务，比如每隔 10 秒钟执行一次任务，我通过这个实现类设置定期执行任务的策略。
- FixedThreadPool：它的核心线程数和最大线程数是一样的，所以可以把它看作是固定线程数的线程池，它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。
- CachedThreadPool：可以称作可缓存线程池，它的特点在于线程数是几乎可以无限增加的（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1，这个数非常大，所以基本不可能达到），而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。
- SingleThreadExecutor：它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。
- SingleThreadScheduledExecutor：它实际和 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程。

#### 线程池中shutdown ()，shutdownNow()这两个方法有什么作用？

- shutdown使用了以后会置状态为SHUTDOWN，正在执行的任务会继续执行下去，没有被执行的则中断。此时，则不能再往线程池中添加任何任务，否则将会抛出 RejectedExecutionException 异常
- 而 shutdownNow 为STOP，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。 它试图终止线程的方法是通过调用 Thread.interrupt() 方法来实现的，但是这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。

### 创建线程的几种方法

1. 继承Theard类，重写run方法，创建实例调用start方法运行。但是因为java的单继承属性，所以不推荐。

- 优点: 编写简单，如果需要访问当前线程，无需使用Thread.currentThread ()方法，直接使用this，即可获得当前线程
- 缺点:因为线程类已经继承了Thread类，所以不能再继承其他的父类

2. 实现Runnable接口，重写run方法，然后将此Runnable对象作为参数传递给Thread类的构造器，创建Thread对象后调用其start()方法启动线程。Runnable接口是函数式接口 只有一个run方法 可以用lambda表达式。

- 优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
- 缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。

3. 实现Callable接口与FutureTask，**Callable的call()方法可以有返回值并且可以抛出异常**。要执行Callable任务，需将它**包装进一个FutureTask**，因为**Thread类的构造器只接受Runnable参数**，而FutureTask实现了Runnable接口。

```java
class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        // 线程执行的代码，这里返回一个整型结果
        return 1;
    }
}

public static void main(String[] args) {
    MyCallable task = new MyCallable();
    FutureTask<Integer> futureTask = new FutureTask<>(task);
    Thread t = new Thread(futureTask);
    t.start();

    try {
        Integer result = futureTask.get();  // 获取线程执行结果
        System.out.println("Result: " + result);
    } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
    }
}
```

- 缺点：编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。
- 优点：线程只是实现Runnable或实现Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。

4. 使用线程池

从Java 5开始引入的java.util.concurrent.ExecutorService和相关类提供了线程池的支持，这是一种更高效的线程管理方式，避免了频繁创建和销毁线程的开销。可以通过Executors类的静态方法创建不同类型的线程池。

创建一个ExecutorService时 返回中有一个属性是 `new LinkedBlockingQueue<Runnable>()` 是一个无界阻塞队列 任务过多会不断加入队列中 JVM可能OOM

```java
class Task implements Runnable {
    @Override
    public void run() {
        // 线程执行的代码
    }
}

public static void main(String[] args) {
    ExecutorService executor = Executors.newFixedThreadPool(10);  // 创建固定大小的线程池
    for (int i = 0; i < 100; i++) {
        executor.submit(new Task());  // 提交任务到线程池执行
    }
    executor.shutdown();  // 关闭线程池
}
```

- 缺点：程池增加了程序的复杂度，特别是当涉及线程池参数调整和故障排查时。错误的配置可能导致死锁、资源耗尽等问题，这些问题的诊断和修复可能较为复杂。
- 优点：线程池可以重用预先创建的线程，避免了线程创建和销毁的开销，显著提高了程序的性能。对于需要快速响应的并发请求，线程池可以迅速提供线程来处理任务，减少等待时间。并且，线程池能够有效控制运行的线程数量，防止因创建过多线程导致的系统资源耗尽（如内存溢出）。通过合理配置线程池大小，可以最大化CPU利用率和系统吞吐量。

### 线程间通信方式有哪些？

1、Object 类的 wait()、notify() 和 notifyAll() 方法。这是 Java 中最基础的线程间通信方式，基于对象的监视器（锁）机制。

- `wait()`：使当前线程进入等待状态，直到其他线程调用该对象的 `notify()` 或 `notifyAll()` 方法。
- `notify()`：唤醒在此对象监视器上等待的单个线程。
- `notifyAll()`：唤醒在此对象监视器上等待的所有线程。

```java
class SharedObject {
    public synchronized void consumerMethod() throws InterruptedException {
        while (/* 条件不满足 */) {
            wait();
        }
        // 执行相应操作
    }

    public synchronized void producerMethod() {
        // 执行相应操作
        notify(); // 或者 notifyAll()
    }
}
```

2、`Lock` 和 `Condition` 接口。`Lock` 接口提供了比 `synchronized` 更灵活的锁机制，`Condition` 接口则配合 `Lock` 实现线程间的等待 / 通知机制。

- `await()`：使当前线程进入等待状态，直到被其他线程唤醒。
- `signal()`：唤醒一个等待在该 `Condition` 上的线程。
- `signalAll()`：唤醒所有等待在该 `Condition` 上的线程。

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class SharedResource {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();

    public void consumer() throws InterruptedException {
        lock.lock();
        try {
            while (/* 条件不满足 */) {
                condition.await();
            }
            // 执行相应操作
        } finally {
            lock.unlock();
        }
    }

    public void producer() {
        lock.lock();
        try {
            // 执行相应操作
            condition.signal(); // 或者 signalAll()
        } finally {
            lock.unlock();
        }
    }
}
```

3、`volatile` 关键字。`volatile` 关键字用于保证变量的可见性，即当一个变量被声明为 `volatile` 时，它会保证对该变量的写操作会立即刷新到主内存中，而读操作会从主内存中读取最新的值。

```java
class VolatileExample {
    private volatile boolean flag = false;

    public void writer() {
        flag = true;
    }

    public void reader() {
        while (!flag) {
            // 等待
        }
        // 执行相应操作
    }
}
```

4、CountDownLatch。`CountDownLatch` 是一个同步辅助类，它允许一个或多个线程等待其他线程完成操作。

- `CountDownLatch(int count)`：构造函数，指定需要等待的线程数量。
- `countDown()`：减少计数器的值。
- `await()`：使当前线程等待，直到计数器的值为 0。

```java
import java.util.concurrent.CountDownLatch;

public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        int threadCount = 3;
        CountDownLatch latch = new CountDownLatch(threadCount);

        for (int i = 0; i < threadCount; i++) {
            new Thread(() -> {
                try {
                    // 执行任务
                    System.out.println(Thread.currentThread().getName() + " 完成任务");
                } finally {
                    latch.countDown();
                }
            }).start();
        }

        latch.await();
        System.out.println("所有线程任务完成");
    }
}
```

5、CyclicBarrier。`CyclicBarrier` 是一个同步辅助类，它允许一组线程相互等待，直到所有线程都到达某个公共屏障点。

- `CyclicBarrier(int parties, Runnable barrierAction)`：构造函数，指定参与的线程数量和所有线程到达屏障点后要执行的操作。
- `await()`：使当前线程等待，直到所有线程都到达屏障点。

```java
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierExample {
    public static void main(String[] args) {
        int threadCount = 3;
        CyclicBarrier barrier = new CyclicBarrier(threadCount, () -> {
            System.out.println("所有线程都到达屏障点");
        });

        for (int i = 0; i < threadCount; i++) {
            new Thread(() -> {
                try {
                    // 执行任务
                    System.out.println(Thread.currentThread().getName() + " 到达屏障点");
                    barrier.await();
                    // 继续执行后续任务
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

6、Semaphore。`Semaphore` 是一个计数信号量，它可以控制同时访问特定资源的线程数量。

- `Semaphore(int permits)`：构造函数，指定信号量的初始许可数量。
- `acquire()`：获取一个许可，如果没有可用许可则阻塞。
- `release()`：释放一个许可。

```java
import java.util.concurrent.Semaphore;

public class SemaphoreExample {
    public static void main(String[] args) {
        int permitCount = 2;
        Semaphore semaphore = new Semaphore(permitCount);

        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + " 获得许可");
                    // 执行任务
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                    System.out.println(Thread.currentThread().getName() + " 释放许可");
                }
            }).start();
        }
    }
}
```

### 停止一个线程的运行

主要有这些方法：

- **异常法停止**：线程调用interrupt()方法后，在线程的run方法中判断当前对象的interrupted()状态，如果是中断状态则抛出异常，达到中断线程的效果。
- **在沉睡中停止**：先将线程sleep，然后调用interrupt标记中断状态，interrupt会将阻塞状态的线程中断。会抛出中断异常，达到停止线程的效果
- **stop()暴力停止**：线程调用stop()方法会被暴力停止，方法已弃用，该方法会有不好的后果：强制让线程停止有可能使一些请理性的工作得不到完成。
- **使用return停止线程**：调用interrupt标记为中断状态后，在run方法中判断当前线程状态，如果为中断状态则return，能达到停止线程的效果。

###  interrupt 是如何让线程抛出异常的

每个线程都一个与之关联的布尔属性来表示其中断状态，中断状态的初始值为false，当一个线程被其它线程调用`Thread.interrupt()`方法中断时，会根据实际情况做出响应。

- 如果该线程正在执行低级别的可中断方法（如`Thread.sleep()`、`Thread.join()`或`Object.wait()`），则会解除阻塞并**抛出`InterruptedException`异常**。
- 否则`Thread.interrupt()`仅设置线程的中断状态，在该被中断的线程中稍后可通过轮询中断状态来决定是否要停止当前正在执行的任务。

### java线程状态

| 线程状态      | 解释                                                         |
| ------------- | ------------------------------------------------------------ |
| NEW           | 尚未启动的线程状态，即线程创建，**还未调用start方法**        |
| RUNNABLE      | **就绪状态**（调用start，等待调度）+**正在运行**             |
| BLOCKED       | **等待监视器锁**时，陷入阻塞状态                             |
| WAITING       | 等待状态的线程正在**等待**另一线程执行特定的操作（如notify） |
| TIMED_WAITING | 具有**指定等待时间**的等待状态                               |
| TERMINATED    | 线程完成执行，**终止状态**                                   |

### BLOCKED和WAITING有啥区别

- BLOCKED是锁竞争失败后被被动触发的状态，WAITING是人为的主动触发的状态
- BLCKED的唤醒时自动触发的，而WAITING状态是必须要通过特定的方法来主动唤醒

### WAITING状态怎么恢复到RUNNABLE状态

`notify()`和`notifyAll()`。

- notify：唤醒一个线程，其他线程依然处于wait的等待唤醒状态，如果被唤醒的线程结束时没调用notify，其他线程就永远没人去唤醒，只能等待超时，或者被中断。具体唤醒对象由JVM确定，随机或者先进先出。
- notifyAll：所有线程退出wait的状态，开始竞争锁，但只有一个线程能抢到，这个线程执行完后，其他线程又会有一个幸运儿脱颖而出得到锁。

### sleep() 和 wait()的区别是什么？

| **特性** | `sleep()`                  | `wait()`                           |
| -------- | -------------------------- | ---------------------------------- |
| 所属类   | `Thread` 类（静态方法）    | `Object` 类（实例方法）            |
| 锁释放   | ❌                          | ✅                                  |
| 使用前提 | 任意位置调用               | 必须在同步块内（持有锁）           |
| 唤醒机制 | 超时自动恢复               | 需 `notify()`/`notifyAll()` 或超时 |
| 设计用途 | 暂停线程执行，不涉及锁协作 | 线程间协调，释放锁让其他线程工作   |

### lock

#### 常用的锁

- **内置锁（synchronized）**：Java中的`synchronized`**关键字**是内置锁机制的基础，可以用于方法或代码块。当一个线程进入`synchronized`代码块或方法时，它会获取关联对象的锁；当线程离开该代码块或方法时，锁会被释放。如果其他线程尝试获取同一个对象的锁，它们将被阻塞，直到锁被释放。其中，syncronized加锁时有无锁、偏向锁、轻量级锁和重量级锁几个级别。偏向锁用于当一个线程进入同步块时，如果没有任何其他线程竞争，就会使用偏向锁，以减少锁的开销。轻量级锁使用线程栈上的数据结构，避免了操作系统级别的锁。重量级锁则涉及操作系统级的互斥锁。
- **ReentrantLock**：`java.util.concurrent.locks.ReentrantLock`是一个显式的锁**类**，提供了比`synchronized`更高级的功能，如可中断的锁等待、定时锁等待、公平锁选项等。`ReentrantLock`使用`lock()`和`unlock()`方法来获取和释放锁。其中，公平锁按照线程请求锁的顺序来分配锁，保证了锁分配的公平性，但可能增加锁的等待时间。非公平锁不保证锁分配的顺序，可以减少锁的竞争，提高性能，但可能造成某些线程的饥饿。公平锁可以通过在创建 ReentrantLock 时传入 true 来设置。公平锁与非公平锁的 lock() 方法唯一的区别就在于公平锁在获取锁时多了一个限制条件：**hasQueuedPredecessors()** 为 false，这个方法就是判断在等待队列中是否已经有线程在排队了。
- **读写锁（ReadWriteLock）**：`java.util.concurrent.locks.ReadWriteLock`接口定义了一种锁，允许多个读取者同时访问共享资源，但只允许一个写入者。读写锁通常用于读取远多于写入的情况，以提高并发性。
- **乐观锁和悲观锁**：悲观锁（Pessimistic Locking）通常指在访问数据前就锁定资源，假设最坏的情况，即数据很可能被其他线程修改。`synchronized`和`ReentrantLock`都是悲观锁的例子。乐观锁（Optimistic Locking）通常不锁定资源，而是在更新数据时检查数据是否已被其他线程修改。乐观锁常使用版本号或时间戳来实现。
- **自旋锁**：自旋锁是一种锁机制，线程在等待锁时会持续循环检查锁是否可用，而不是放弃CPU并阻塞。通常可以使用CAS来实现。这在锁等待时间很短的情况下可以提高性能，但过度自旋会浪费CPU资源。



### synchronized与volatile与CAS与AQS

#### volatile

- **保证变量对所有线程的可见性**。当一个变量被声明为volatile时，它会保证对这个变量的写操作会立即刷新到主存中，而对这个变量的读操作会直接从主存中读取，从而确保了多线程环境下对该变量访问的可见性。这意味着一个线程修改了volatile变量的值，其他线程能够立刻看到这个修改，不会受到各自线程工作内存的影响。
- **禁止指令重排序优化**。volatile关键字在Java中主要通过内存屏障来禁止特定类型的指令重排序。
  - **写-写（Write-Write）屏障**：在对volatile变量执行**写操作之前，会插入一个写屏障**。这确保了在该变量写操作之前的所有普通写操作都已完成，防止了这些写操作被移到volatile写操作之后。
  - **写-读（Write-Read）屏障**：这是最重要的一个屏障，它发生在volatile写之后和volatile读之前。这个屏障确保了volatile写操作之前的所有内存操作（包括写操作）都不会被重排序到volatile读之后，同时也确保了volatile读操作之后的所有内存操作（包括读操作）都不会被重排序到volatile写之前。
  - **读-写（Read-Write）屏障**：在对volatile变量**执行读操作之后，会插入一个读屏障**。它确保了对volatile变量的读操作之后的所有普通读操作都不会被提前到volatile读之前执行，保证了读取到的数据是最新的。

#### synchronized

- synchronized 可用来修饰普通方法、静态方法和代码块

- synchronized是Java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为**监视器锁**。

  在使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。

  执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。此时其他竞争锁的线程则会进入等待队列中。执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。

- 锁升级：**无锁->偏向锁->轻量级锁->重量级锁**

  - **无锁**：这是没有开启偏向锁的时候的状态，在JDK1.6之后偏向锁的默认开启的，但是有一个偏向延迟，需要在JVM启动之后的多少秒之后才能开启，这个可以通过JVM参数进行设置，同时是否开启偏向锁也可以通过JVM参数设置。
  - **偏向锁**：这个是在偏向锁开启之后的锁的状态，如果还没有一个线程拿到这个锁的话，这个状态叫做匿名偏向，当一个线程拿到偏向锁的时候，下次想要竞争锁只需要拿线程ID跟MarkWord当中存储的线程ID进行比较，如果线程ID相同则直接获取锁（相当于锁偏向于这个线程），不需要进行CAS操作和将线程挂起的操作。
  - **轻量级锁**：在这个状态下线程主要是通过CAS操作实现的。将对象的MarkWord存储到线程的虚拟机栈上，然后通过CAS将对象的MarkWord的内容设置为指向Displaced Mark Word的指针，如果设置成功则获取锁。在线程出临界区的时候，也需要使用CAS，如果使用CAS替换成功则同步成功，如果失败表示有其他线程在获取锁，那么就需要在释放锁之后将被挂起的线程唤醒。
  - **重量级锁**：当有两个以上的线程获取锁的时候轻量级锁就会升级为重量级锁，因为CAS如果没有成功的话始终都在自旋，进行while循环操作，这是非常消耗CPU的，但是在升级为重量级锁之后，线程会被操作系统调度然后挂起，这可以节约CPU资源。

- jvm对synchronized的优化

  - **锁膨胀**：synchronized 从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程，它叫做锁膨胀也叫做锁升级。JDK 1.6 之前，synchronized 是重量级锁，也就是说 synchronized 在释放和获取锁时都会从用户态转换成内核态，而转换的效率是比较低的。但有了锁膨胀机制之后synchronized 的状态就多了无锁、偏向锁以及轻量级锁了，这时候在进行并发操作时，大部分的场景都不需要用户态到内核态的转换了，这样就大幅的提升了 synchronized 的性能。
  - **锁消除**：指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的。
  - **锁粗化**：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。
  - **自适应自旋锁**：指通过自身循环，尝试获取锁的一种方式，优点在于它避免一些线程的挂起和恢复操作，因为挂起线程和恢复线程都需要从用户态转入内核态，这个过程是比较慢的，所以通过自旋的方式可以一定程度上避免线程挂起和恢复所造成的性能开销。

#### CAS

- CAS 是一种**乐观锁**机制，它包含三个操作数：内存位置（V）、预期值（A）和新值（B）。CAS 操作的逻辑是，如果内存位置 V 的值等于预期值 A，则将其更新为新值 B，否则不做任何操作。整个过程是原子性的，通常由硬件指令支持，如在现代处理器上，`cmpxchg` 指令可以实现 CAS 操作。
- CAS 的逻辑是：“我认为内存地址 V 的值应该是 A，如果是，那么把它改成 B；如果不是（说明在我准备修改的期间，有其他线程已经修改了它），那我就不改了。”
- CAS的缺点主要有3点：

  - **ABA问题**：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终效果。Java中有AtomicStampedReference来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。（可以用volatile关键字共享变量状态解决）
  - **循环时间长开销大**：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。
  - **只能保证一个共享变量的原子操作**：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。
- CAS操作是基于循环重试的机制，如果CAS操作一直未能成功，线程会一直自旋重试，占用CPU资源。在高并发情况下，大量线程自旋会导致CPU资源浪费。

#### AQS

AQS全称为AbstractQueuedSynchronizer，是Java中的一个抽象类。 AQS是一个用于构建锁、同步器、协作工具类的工具类（框架）。

AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。

AQS中的队列是CLH(CLH：Craig、Landin and Hagersten队列，是单向链表)变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。

AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。

AQS最核心的就是三大部分：

- 状态：state,这里state的具体含义，会根据具体实现类的不同而不同：比如在Semapore里，他表示剩余许可证的数量；在CountDownLatch里，它表示还需要倒数的数量；在ReentrantLock中，state用来表示“锁”的占有情况，包括可重入计数，当state的值为0的时候，标识该Lock不被任何线程所占有。state是volatile修饰的，并被并发修改，所以修改state的方法都需要保证线程安全，比如getState、setState以及compareAndSetState操作来读取和更新这个状态。这些方法都依赖于unsafe类。
- 控制线程抢锁和配合的FIFO队列（双向链表）；这个队列用来存放“等待的线程，AQS就是“排队管理器”，当多个线程争用同一把锁时，必须有排队机制将那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁。AQS会维护一个等待的线程队列，把线程都放到这个队列里，这个队列是双向链表形式。
- 期望协作工具类去实现的获取/释放等重要方法（重写）。这里的获取和释放方法，是利用AQS的协作工具类里最重要的方法，是由协作类自己去实现的，并且含义各不相同；

AQS 是一个用于构建锁和同步器的框架，许多同步器如 `ReentrantLock`、`Semaphore`、`CountDownLatch` 等都是基于 AQS 构建的。**AQS 使用一个 `volatile` 的整数变量 `state` 来表示同步状态，通过内置的 `FIFO` 队列来管理等待线程。**它提供了一些基本的操作，如 `acquire`（获取资源）和 `release`（释放资源），这些操作会修改 `state` 的值，并根据 `state` 的值来判断线程是否可以获取或释放资源。AQS 的 `acquire` 操作通常会先尝试获取资源，如果失败，线程将被添加到等待队列中，并阻塞等待。`release` 操作会释放资源，并唤醒等待队列中的线程。

### 并发工具包

#### 常用并发工具

- **CountDownLatch**：CountDownLatch 是一个同步辅助类，它允许一个或多个线程等待其他线程完成操作。它使用一个计数器进行初始化，调用 `countDown()` 方法会使计数器减一，当计数器的值减为 0 时，等待的线程会被唤醒。可以把它想象成一个倒计时器，当倒计时结束（计数器为 0）时，等待的事件就会发生。示例代码：

```java
import java.util.concurrent.CountDownLatch;

public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        int numberOfThreads = 3;
        CountDownLatch latch = new CountDownLatch(numberOfThreads);

        // 创建并启动三个工作线程
        for (int i = 0; i < numberOfThreads; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + " 正在工作");
                try {
                    Thread.sleep(1000);  // 模拟工作时间
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                latch.countDown();  // 完成工作，计数器减一
                System.out.println(Thread.currentThread().getName() + " 完成工作");
            }).start();
        }

        System.out.println("主线程等待工作线程完成");
        latch.await();  // 主线程等待，直到计数器为 0
        System.out.println("所有工作线程已完成，主线程继续执行");
    }
}
```

- **CyclicBarrier**：CyclicBarrier 允许一组线程互相等待，直到到达一个公共的屏障点。当所有线程都到达这个屏障点后，它们可以继续执行后续操作，并且这个屏障可以被重置循环使用。与 `CountDownLatch` 不同，`CyclicBarrier` 侧重于线程间的相互等待，而不是等待某些操作完成。示例代码：

```java
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierExample {
    public static void main(String[] args) {
        int numberOfThreads = 3;
        CyclicBarrier barrier = new CyclicBarrier(numberOfThreads, () -> {
            System.out.println("所有线程都到达了屏障，继续执行后续操作");
        });

        for (int i = 0; i < numberOfThreads; i++) {
            new Thread(() -> {
                try {
                    System.out.println(Thread.currentThread().getName() + " 正在运行");
                    Thread.sleep(1000);  // 模拟运行时间
                    barrier.await();  // 等待其他线程
                    System.out.println(Thread.currentThread().getName() + " 已经通过屏障");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

- **Semaphore**：Semaphore 是一个计数信号量，用于控制同时访问某个共享资源的线程数量。通过 `acquire()` 方法获取许可，使用 `release()` 方法释放许可。如果没有许可可用，线程将被阻塞，直到有许可被释放。可以用来限制对某些资源（如数据库连接池、文件操作等）的并发访问量。代码如下：

```java
import java.util.concurrent.Semaphore;

public class SemaphoreExample {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(2);  // 允许 2 个线程同时访问

        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire();  // 获取许可
                    System.out.println(Thread.currentThread().getName() + " 获得了许可");
                    Thread.sleep(2000);  // 模拟资源使用
                    System.out.println(Thread.currentThread().getName() + " 释放了许可");
                    semaphore.release();  // 释放许可
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

- **Future 和 Callable**：Callable 是一个类似于 `Runnable` 的接口，但它可以返回结果，并且可以抛出异常。Future 用于表示一个异步计算的结果，可以通过它来获取 `Callable` 任务的执行结果或取消任务。代码如下：

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class FutureCallableExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        Callable<Integer> callable = () -> {
            System.out.println(Thread.currentThread().getName() + " 开始执行 Callable 任务");
            Thread.sleep(2000);  // 模拟耗时操作
            return 42;  // 返回结果
        };

        Future<Integer> future = executorService.submit(callable);
        System.out.println("主线程继续执行其他任务");

        try {
            Integer result = future.get();  // 等待 Callable 任务完成并获取结果
            System.out.println("Callable 任务的结果: " + result);
        } catch (Exception e) {
            e.printStackTrace();
        }

        executorService.shutdown();
    }
}
```

- **ConcurrentHashMap**：ConcurrentHashMap 是一个线程安全的哈希表，它允许多个线程同时进行读操作，在一定程度上支持并发的修改操作，避免了 `HashMap` 在多线程环境下需要使用 `synchronized` 或 `Collections.synchronizedMap()` 进行同步的性能问题。代码如下：

```java
import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapExample {
    public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        map.put("key1", 1);
        map.put("key2", 2);

        // 并发读操作
        map.forEach((key, value) -> System.out.println(key + ": " + value));

        // 并发写操作
        map.computeIfAbsent("key3", k -> 3);
    }
}
```

#### CountDownLatch 是做什么的讲一讲？

CountDownLatch 是 Java 并发包（`java.util.concurrent`）中的一个同步工具类，**用于让一个或多个线程等待其他线程完成操作后再继续执行**。

其核心是通过一个计数器（Counter）实现线程间的协调，常用于多线程任务的分阶段控制或主线程等待多个子线程就绪的场景，核心原理：

- **初始化计数器**：创建 `CountDownLatch` 时指定一个初始计数值（如 `N`）。
- **等待线程阻塞**：调用 `await()` 的线程会被阻塞，直到计数器变为 0。
- **任务完成通知**：其他线程完成任务后调用 `countDown()`，使计数器减 1。
- **唤醒等待线程**：当计数器减到 0 时，所有等待的线程会被唤醒。

主线程等待所有子线程就绪后启动，代码例子如下：

```java
// 主线程启动多个子线程执行任务，等待全部完成后统计结果
public class MainThreadWaitExample {
    public static void main(String[] args) throws InterruptedException {
        int threadCount = 3;
        CountDownLatch latch = new CountDownLatch(threadCount);

        for (int i = 0; i < threadCount; i++) {
            new Thread(() -> {
                try {
                    System.out.println(Thread.currentThread().getName() + " 执行任务");
                    Thread.sleep(1000);
                    latch.countDown(); // 任务完成，计数器-1
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Worker-" + i).start();
        }

        latch.await(); // 主线程等待所有子线程完成任务
        System.out.println("所有任务已完成");
    }
```

### 死锁

死锁只有**同时满足**以下四个条件才会发生：

- 互斥条件：互斥条件是指**多个线程不能同时使用同一个资源**。
- 持有并等待条件：持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是**线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1**。
- 不可剥夺条件：不可剥夺条件是指，当线程已经持有了资源 ，**在自己使用完之前不能被其他线程获取**，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。
- 环路等待条件：环路等待条件指的是，在死锁发生的时候，**两个线程获取资源的顺序构成了环形链**。

## java的设计模式

### 单例模式

**单例模式（Singleton Pattern）** 是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来获取这个唯一的实例。

**核心思想：**

1. **私有化构造函数：** 为了防止外部通过 `new` 操作符直接创建类的多个实例，需要将类的构造函数声明为私有的（private）。
2. **静态私有实例：** 在类的内部创建一个静态的、私有的自身实例。
3. **公共静态访问方法：** 提供一个公共的静态方法（通常命名为 `getInstance()`），用于返回类唯一的实例。这个方法会检查实例是否已经被创建，如果尚未创建，则创建新实例；如果已经创建，则直接返回现有实例。

**为什么使用单例模式？**

- **资源共享与控制：** 当某个对象需要被多个模块共享，并且其状态需要被统一管理时，例如数据库连接池、线程池、日志对象、配置文件读取对象等。
- **性能优化：** 避免重复创建和销毁对象带来的性能开销，特别是对于那些创建成本较高的对象。
- **确保唯一性：** 在某些场景下，逻辑上要求一个类只能有一个实例，例如计数器、系统全局配置等。

**常见的实现方式：**

1. **饿汉式（Eager Initialization）：** 类加载时就立即创建实例。这种方式线程安全，但可能造成资源浪费（如果实例一直未使用）。

2. 懒汉式（Lazy Initialization）：

    第一次调用 `getInstance()`方法时才创建实例。这种方式延迟了对象的创建，但需要处理线程安全问题。

   - **线程不安全的懒汉式：** 在多线程环境下可能创建多个实例。
   - **线程安全的懒汉式（同步方法）：** 使用 `synchronized` 关键字修饰 `getInstance()` 方法，但会影响性能。
   - **线程安全的懒汉式（双重检查锁定 - Double-Checked Locking）：** 在同步代码块内外都进行判空，以提高性能，但需要注意 `volatile` 关键字的使用。

3. **静态内部类（Static Inner Class）：** 利用 JVM 类加载机制来保证线程安全和延迟加载。当 `getInstance()` 方法第一次被调用时，才会加载静态内部类，从而创建实例。这是一种推荐的实现方式。

4. **枚举（Enum）：** 最简洁、最安全的单例实现方式，天然防止反射和反序列化漏洞。这是 Effective Java 作者 Joshua Bloch 推荐的方式。

饿汉式

```java
public class EagerSingleton {

    // 1. 类加载时就立即创建实例
    private static final EagerSingleton instance = new EagerSingleton();

    // 2. 私有化构造函数
    private EagerSingleton() {
        System.out.println("饿汉式单例：实例被创建了");
    }

    // 3. 公共静态访问方法
    public static EagerSingleton getInstance() {
        return instance;
    }

    public void showMessage() {
        System.out.println("这是一个饿汉式单例的方法。");
    }

    public static void main(String[] args) {
        EagerSingleton singleton1 = EagerSingleton.getInstance();
        EagerSingleton singleton2 = EagerSingleton.getInstance();

        System.out.println("singleton1 和 singleton2 是同一个实例吗？ " + (singleton1 == singleton2));
        singleton1.showMessage();
    }
}
```

懒汉式

```java
public class LazySingletonWithDoubleCheck {

    // 1. 静态私有实例，使用 volatile 保证多线程环境下的可见性和禁止指令重排
    private static volatile LazySingletonWithDoubleCheck instance;

    // 2. 私有化构造函数
    private LazySingletonWithDoubleCheck() {
        System.out.println("懒汉式（双重检查锁定）单例：实例被创建了");
    }

    // 3. 公共静态访问方法
    public static LazySingletonWithDoubleCheck getInstance() {
        // 第一次检查，如果实例已存在，则直接返回，避免不必要的同步开销
        if (instance == null) {
            // 同步代码块，确保只有一个线程可以创建实例
            synchronized (LazySingletonWithDoubleCheck.class) {
                // 第二次检查，防止多个线程同时通过第一次检查并等待锁时重复创建实例
                if (instance == null) {
                    instance = new LazySingletonWithDoubleCheck();
                }
            }
        }
        return instance;
    }

    public void showMessage() {
        System.out.println("这是一个懒汉式（双重检查锁定）单例的方法。");
    }

    public static void main(String[] args) {
        // 多线程测试
        Thread t1 = new Thread(() -> {
            LazySingletonWithDoubleCheck singleton = LazySingletonWithDoubleCheck.getInstance();
            System.out.println("线程1获取的实例: " + singleton.hashCode());
            singleton.showMessage();
        });

        Thread t2 = new Thread(() -> {
            LazySingletonWithDoubleCheck singleton = LazySingletonWithDoubleCheck.getInstance();
            System.out.println("线程2获取的实例: " + singleton.hashCode());
            singleton.showMessage();
        });

        t1.start();
        t2.start();

        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        LazySingletonWithDoubleCheck singleton1 = LazySingletonWithDoubleCheck.getInstance();
        LazySingletonWithDoubleCheck singleton2 = LazySingletonWithDoubleCheck.getInstance();
        System.out.println("主线程中 singleton1 和 singleton2 是同一个实例吗？ " + (singleton1 == singleton2));
    }
}
```

静态内部类 (Static Inner Class)

这是一种推荐的、优雅的线程安全懒汉式实现。

```java
public class StaticInnerClassSingleton {

    // 2. 私有化构造函数
    private StaticInnerClassSingleton() {
        System.out.println("静态内部类单例：实例被创建了");
    }

    // 1. 静态内部类，持有外部类的唯一实例
    private static class SingletonHolder {
        private static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();
    }

    // 3. 公共静态访问方法
    public static StaticInnerClassSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }

    public void showMessage() {
        System.out.println("这是一个静态内部类单例的方法。");
    }

    public static void main(String[] args) {
        StaticInnerClassSingleton singleton1 = StaticInnerClassSingleton.getInstance();
        StaticInnerClassSingleton singleton2 = StaticInnerClassSingleton.getInstance();

        System.out.println("singleton1 和 singleton2 是同一个实例吗？ " + (singleton1 == singleton2));
        singleton1.showMessage();

        // 多线程测试
        new Thread(() -> System.out.println("线程1获取的实例: " + StaticInnerClassSingleton.getInstance().hashCode())).start();
        new Thread(() -> System.out.println("线程2获取的实例: " + StaticInnerClassSingleton.getInstance().hashCode())).start();
    }
}
```

枚举

```java
public enum EnumSingleton {
    INSTANCE; // 定义一个枚举元素，它本身就是单例的实例

    // 构造函数默认是私有的
    EnumSingleton() {
        System.out.println("枚举单例：实例被创建了");
    }

    public void showMessage() {
        System.out.println("这是一个枚举单例的方法。");
    }

    public static void main(String[] args) {
        EnumSingleton singleton1 = EnumSingleton.INSTANCE;
        EnumSingleton singleton2 = EnumSingleton.INSTANCE;

        System.out.println("singleton1 和 singleton2 是同一个实例吗？ " + (singleton1 == singleton2));
        System.out.println("singleton1 hashCode: " + singleton1.hashCode());
        System.out.println("singleton2 hashCode: " + singleton2.hashCode());
        singleton1.showMessage();

        // 枚举单例天然防止反射创建新实例
        // 枚举单例也天然处理了序列化和反序列化的问题
    }
}
```

好的，这是一个更精简的对比表格，聚焦核心差异和推荐：

| 实现方式         | 线程安全 | 懒加载 | 核心特点与推荐                                           |
| ---------------- | -------- | ------ | -------------------------------------------------------- |
| **饿汉式**       | 是       | 否     | 简单，类加载时即创建。若资源消耗不大或必须预加载，可用。 |
| **懒汉式**       | 否       | 是     | 需额外处理线程安全 (如加锁，影响性能)。不特别推荐。      |
| **双重检查锁定** | 是       | 是     | 懒加载+较高性能。实现稍复杂，需用 `volatile`。           |
| **静态内部类**   | 是       | 是     | **非常推荐**：利用JVM机制，线程安全，懒加载，简洁。      |
| **枚举**         | 是       | 否     | **最佳推荐**：最简单，天然防反射和序列化。               |

### 工厂模式

通常我们说的“工厂模式”可以指代以下三种具体的模式：

1. **简单工厂模式 (Simple Factory Pattern)** - 也常被称为静态工厂方法模式。
2. **工厂方法模式 (Factory Method Pattern)** - GoF (Gang of Four) 设计模式之一。
3. **抽象工厂模式 (Abstract Factory Pattern)** - GoF 设计模式之一。

#### 简单工厂模式 (Simple Factory Pattern)

简单工厂模式不是 23 种经典 GoF 设计模式之一，但它是一种非常常见且易于理解的编程习惯。

**核心思想：** 定义一个工厂类，该类可以根据传入的参数（或配置）来决定创建并返回哪一种具体的产品类的实例。

**结构：**

- **Product (产品接口/抽象类)：** 定义了工厂所创建的对象的共同接口。
- **ConcreteProduct (具体产品类)：** 实现了 Product 接口，是工厂创建的目标对象。
- **Factory (工厂类)：** 包含一个静态方法（或普通方法），根据传入的参数创建并返回不同的 ConcreteProduct 实例。

**优点：**

- **封装创建逻辑：** 将对象的创建逻辑集中在一个地方，客户端代码与具体产品解耦。
- **简单直观：** 实现起来比较简单。

**缺点：**

- **违反开闭原则：** 如果需要增加新的产品类型，通常需要修改工厂类的判断逻辑，这违反了“对扩展开放，对修改关闭”的原则。
- **职责过重：** 当产品类型很多时，工厂类的逻辑会变得非常复杂。

假设我们要创建一个可以生产不同形状的工厂：

```java
// 1. 产品接口
interface Shape {
    void draw();
}

// 2. 具体产品类
class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("画一个圆形");
    }
}

class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("画一个矩形");
    }
}

class Square implements Shape {
    @Override
    public void draw() {
        System.out.println("画一个正方形");
    }
}

// 3. 简单工厂类
class ShapeFactory {
    // 通常使用静态方法
    public static Shape getShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
            return new Rectangle();
        } else if (shapeType.equalsIgnoreCase("SQUARE")) {
            return new Square();
        }
        return null;
    }
}

// 客户端使用
public class SimpleFactoryDemo {
    public static void main(String[] args) {
        Shape shape1 = ShapeFactory.getShape("CIRCLE");
        if (shape1 != null) {
            shape1.draw();
        }

        Shape shape2 = ShapeFactory.getShape("RECTANGLE");
        if (shape2 != null) {
            shape2.draw();
        }
    }
}
```

#### 工厂方法模式 (Factory Method Pattern)

**核心思想：** 定义一个用于创建对象的接口（工厂接口），但让实现这个接口的子类（具体工厂类）来决定实例化哪一个产品类。工厂方法模式将对象的实例化延迟到子类中进行。

**结构：**

- **Product (产品接口/抽象类)：** 定义了工厂方法所创建的对象的接口。
- **ConcreteProduct (具体产品类)：** 实现了 Product 接口。
- **Creator (创建者接口/抽象类)：** 声明了工厂方法（`factoryMethod()`），该方法返回一个 Product 类型的对象。Creator 也可以定义一个默认的工厂方法实现。
- **ConcreteCreator (具体创建者类)：** 实现了 Creator 接口或继承了 Creator 抽象类，重写工厂方法以返回一个具体的 ConcreteProduct 实例。

**优点：**

- **良好的开闭原则：** 增加新的产品时，只需要增加对应的具体产品类和具体工厂类，无需修改现有工厂或产品代码（除了可能需要客户端知道新的具体工厂）。
- **解耦：** 将产品的实例化过程从客户端代码中分离出来，由子类完成。
- **灵活性高：** 客户端可以针对抽象的 Creator 和 Product 编程，具体使用哪个产品由具体工厂决定。

**缺点：**

- **类的数量增加：** 每增加一个产品，就需要增加一个具体产品类和一个相应的具体工厂类，这会使得系统中的类数量成倍增加，增加了系统的复杂度。

```java
// 1. 产品接口 (同上)
// interface Shape { void draw(); }
// class Circle implements Shape { ... }
// class Rectangle implements Shape { ... }

// 3. 创建者接口 (工厂接口)
interface ShapeFactoryCreator {
    Shape createShape(); // 工厂方法
}

// 4. 具体创建者类 (具体工厂)
class CircleFactory implements ShapeFactoryCreator {
    @Override
    public Shape createShape() {
        return new Circle();
    }
}

class RectangleFactory implements ShapeFactoryCreator {
    @Override
    public Shape createShape() {
        return new Rectangle();
    }
}

// 客户端使用
public class FactoryMethodDemo {
    public static void main(String[] args) {
        ShapeFactoryCreator circleFactory = new CircleFactory();
        Shape circle = circleFactory.createShape();
        circle.draw();

        ShapeFactoryCreator rectangleFactory = new RectangleFactory();
        Shape rectangle = rectangleFactory.createShape();
        rectangle.draw();

        // 如果要增加 Square
        // 1. 创建 Square 类 (ConcreteProduct)
        // 2. 创建 SquareFactory 类 (ConcreteCreator)
        // ShapeFactoryCreator squareFactory = new SquareFactory();
        // Shape square = squareFactory.createShape();
        // square.draw();
    }
}
```

#### 抽象工厂模式 (Abstract Factory Pattern)

抽象工厂模式也是 GoF 定义的一种创建型设计模式，它处理的是“产品族”的创建问题。

**核心思想：** 提供一个接口，用于创建**一系列相关或相互依赖的对象（一个产品族）**，而无需指定它们具体的类。客户端使用抽象工厂来获取所需产品族中的对象。

**结构：**

- **AbstractFactory (抽象工厂接口)：** 声明了一组用于创建抽象产品的方法，每个方法对应一个产品族中的产品。
- **ConcreteFactory (具体工厂类)：** 实现了 AbstractFactory 接口，负责创建具体产品族中的产品。
- **AbstractProduct (抽象产品接口)：** 定义了产品族中一类产品的接口。
- **ConcreteProduct (具体产品类)：** 实现了 AbstractProduct 接口，是具体工厂创建的具体产品对象。
- **Client (客户端)：** 使用 AbstractFactory 和 AbstractProduct 接口来操作对象。

**优点：**

- **隔离具体类：** 客户端代码只依赖于抽象工厂和抽象产品，与具体实现解耦。
- **易于交换产品族：** 只需要改变具体的工厂实例，就可以改变整个产品族，对客户端代码影响很小。
- **保证产品兼容性：** 当一个工厂创建的产品被设计为需要一起工作时，抽象工厂模式能保证客户端始终只使用同一个工厂创建的对象，从而保证了它们之间的兼容性。

**缺点：**

- **难以扩展新的产品种类：** 如果要向产品族中增加新的产品种类（例如，从生产“按钮”和“文本框”的UI工厂，扩展到也生产“复选框”），就需要修改抽象工厂的接口，这会导致所有具体工厂子类都需要修改，违反了开闭原则。

```java
// --- 抽象产品 ---
interface Button {
    void paint();
}

interface TextField {
    void display();
}

// --- 具体产品 (Windows 风格) ---
class WindowsButton implements Button {
    @Override
    public void paint() {
        System.out.println("渲染一个 Windows 风格的按钮");
    }
}

class WindowsTextField implements TextField {
    @Override
    public void display() {
        System.out.println("显示一个 Windows 风格的文本框");
    }
}

// --- 具体产品 (MacOS 风格) ---
class MacOSButton implements Button {
    @Override
    public void paint() {
        System.out.println("渲染一个 MacOS 风格的按钮");
    }
}

class MacOSTextField implements TextField {
    @Override
    public void display() {
        System.out.println("显示一个 MacOS 风格的文本框");
    }
}

// --- 抽象工厂接口 ---
interface GUIFactory {
    Button createButton();
    TextField createTextField();
}

// --- 具体工厂 (Windows 工厂) ---
class WindowsGUIFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new WindowsButton();
    }

    @Override
    public TextField createTextField() {
        return new WindowsTextField();
    }
}

// --- 具体工厂 (MacOS 工厂) ---
class MacOSGUIFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new MacOSButton();
    }

    @Override
    public TextField createTextField() {
        return new MacOSTextField();
    }
}

// --- 客户端 ---
class Application {
    private Button button;
    private TextField textField;

    public Application(GUIFactory factory) {
        button = factory.createButton();
        textField = factory.createTextField();
    }

    public void renderUI() {
        button.paint();
        textField.display();
    }
}

public class AbstractFactoryDemo {
    public static void main(String[] args) {
        String osName = System.getProperty("os.name").toLowerCase();
        GUIFactory factory;

        if (osName.contains("win")) {
            factory = new WindowsGUIFactory();
        } else if (osName.contains("mac")) {
            factory = new MacOSGUIFactory();
        } else {
            // 默认或抛出异常
            System.out.println("不支持的操作系统，使用默认 Windows 风格");
            factory = new WindowsGUIFactory();
        }

        Application app = new Application(factory);
        app.renderUI();

        // 切换到 MacOS 风格 (如果需要)
        System.out.println("\n--- 切换到 MacOS 风格 ---");
        GUIFactory macOSFactory = new MacOSGUIFactory();
        Application macOSApp = new Application(macOSFactory);
        macOSApp.renderUI();
    }
}
```

- **简单工厂模式：** 当创建的对象类型较少，且不经常变化时，可以用于封装创建逻辑。它是对直接 `new` 对象的一种简单改进。

- **工厂方法模式：** 当你需要将对象的创建委托给子类，并且希望子类可以灵活地决定创建哪种具体对象时使用。它很好地体现了开闭原则（对扩展产品类型开放）。（更注重抽象方法）

- **抽象工厂模式：** 当你需要创建一系列相互关联或相互依赖的对象（一个产品族），并且希望客户端代码与具体的产品实现解耦，能够轻松切换整个产品族时使用。它侧重于“族”的概念。（更注重抽象产品）
- **简单工厂模式：** 核心在于**封装创建逻辑**，通过一个集中的工厂类根据条件返回不同产品。特点是“简单”。
- **工厂方法模式：** 核心在于**延迟实例化到子类**，通过定义一个抽象的“工厂方法”，让子类决定创建哪个具体产品。特点是“注重抽象的创建方法”。
- **抽象工厂模式：** 核心在于**创建产品族**，通过定义一个抽象工厂接口来声明一组创建相关抽象产品的方法，由具体工厂实现这个接口来生产特定主题（或系列）的产品族。特点是“注重创建一系列相关的抽象产品（产品族）”。

