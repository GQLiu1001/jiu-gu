# JVM

## JVM的组成

- Java堆：JVM中最大的一块内存区域，被所有线程共享，虚拟机启动时创建，用于存放对象实例。 其内存区域可以分为两部分：新生代和老年代（大对象一般直接分配进去），新生代`1/3`，在新生代内其被划分为三个区域：Eden区与S0、S1区，Eden区最大`8/10`，在经历GC后存活的对象会从Eden区移动到S0，再次GC后依旧存活移动到S1，再一次或多次GC后移动到老年代，相对于`Minor GC`老年代内的`Major GC`频率低执行时间长。堆内拥有`Srting`常量池`Integer`常量池等。堆的存取速度相对慢（对象在堆内存上的分配和回收需要更多的时间，而且垃圾回收机制会影响性能）。

- Java虚拟机栈：每个线程有独立的Java虚拟机栈，生命周期与线程相同，每个方法执行会创建一个栈帧（存储方法的信息），存放局部变量等。如一条指令`A a = new A("13",2)`的执行，首先会在堆里创建一个 `new A("13",2)`的实例，在当前方法执行的线程的Java虚拟栈中的当先正在执行方法的栈帧内，会在局部变量表创建一个`a`的引用变量，最后`=`会将实例的地址交给`a`。在方法执行完成后该栈帧会销毁（如果局部变量是对象引用，这个引用会消失）。至于堆内实例的生命周期由GC检测。栈的存取速度快（FILO）操作简单快速。

- 本地方法栈：为native方法服务，同样在方法执行时会创建栈帧。

- “程序计数器：当前线程私有的，可以看作是当前线程所执行的字节码的行号指示器。它记录了当前线程正在执行的Java方法的JVM指令地址（如果执行的是Native方法，则此计数器值为空）。**在多线程环境下，当一个线程的时间片用完或者因其他原因需要切换时，它的程序计数器的值会作为其执行上下文的一部分被保存下来。当该线程再次被调度执行时，程序计数器的值会被恢复，从而确保线程能够从正确的指令位置继续执行。**

- 元空间：方法区的具体实现，使用的是本地内存而不是JVM堆内存。存储被JVM加载的类信息、常量、静态变量等数据。

- JIT：JVM引擎的一部分，会编译并缓存热点代码并将编译后的本地机器码缓存在代码缓存中。

## JVM中的内存泄漏和内存溢出

- 内存泄露：程序在运行过程中不再使用的对象依然被引用，而无法被GC，从而导致可用内存越来越少。
  - 常见原因：静态集合存储且未清理，事件监听没取消被持续引用。
- 内存溢出：JVM申请内存时无法找到足够内存。
  - 常见原因：大量对象创建超过堆限制，大型数据长时间被引用，递归栈溢出。
  - 溢出情况：堆溢出`OutOfMemoryError`，栈溢出`StackOverFlowError`
- 常见优化：
  - 减少静态变量
  - 单例尽量懒加载
  - 使用`TheardLocal`（线程隔离，线程安全）提供的`remove()`来清理值。

## JVM中的对象

Java中一个对象创建的过程：

类加载检查（遇到一个new指令时，先检查是否能在常量池定位到一个类的符号引用（表示类的全限定名），并且检查这个符号引用代表的类是否被加载、验证、准备和初始化过。如果没有必须先执行相应的**类加载**过程），分配内存，初始化零值，设置对象头（哪个类的实例，如何找到类的元数据信息，对象哈希码对象GC分代年龄等信息存放进对象头中），执行`init()`方法。

对象的生命周期：

创建，使用以及销毁，通过GC会回收对象占用的内存空间。

## JVM中的类加载

jvm中的类加载器：

- 顶级： 启动类加载器
  - 负责加载Java核心库
- 二级：扩展类加载器
  - 负责加载java扩展目录下的jar包类库
- 三级：应用程序类加载器
  - 负责加载用户类路径上指定类库
- 四级：自定义类加载器
  - 可自定义类的加载方式

类加载器的双亲委派机制：

当一个类要被加载时会一直将请求传递到最上层，只有最上层反馈其**加载的范围内**不包含此类才会让下一级进行尝试。

保证了：

- 类的唯一性：避免不同类加载器加载相同类，保证Java核心类库的统一性。
- 保证安全性：保护核心类。系统安全性。
- 隔离性与层次划分：不同类加载器有自己的加载范围，善于维护和扩展。
- 简化加载流程

类加载的过程：

加载：通过类的全限定名（包名+类名），获取该类的`.class`文件的二进制字节流并转化为方法区运行时的数据结构，在内存中生产一个代表该类的`Class`对象，作为方法区这个类的各种数据访问入口。

链接：

​	验证：是否安全符合标准。

​	准备：分配内存，设置默认初始值。

​	解析：将符号引用转换为直接引用。

初始化：执行类的构造器方法

使用

卸载：当类的所有实例被回收/`Class`对象不再被引用/加载该类的`ClassLoader`类加载器被回收。

## JVM的垃圾回收

判断垃圾的方法：

- 引用计数法：当被引用计数器加1，失效减1，为0则可被回收。当两个对象循环引用时失效。
- 可达性分析：从一组`GC Roots`对象出发，向下追溯它们引用的对象，以及这些对象引用的其他对象，如果一个对象到`GC Roots`没有任何链路链接，即不可达，就可以被回收。`GC Roots`对象包括：虚拟机**栈**中引用的对象、方法区中静态属性引用的对象、本地方法**栈**中引用的对象等。

回收垃圾的算法：

- 复制算法：最快但内存利用率不足，将内存分为两片，每次申请内存都只使用其中一块，内存不够时将这一块内存中存活的复制到另一块接着清理原本一块。
- 标记-清除算法：效率不高且空间碎片化，首先分为标记和清除两阶段，首先进行可达性分析，标记对象，然后统一回收。
- 标记-整理算法：效率高，在标记后先将存活对象移动内存一端，接着清理剩下部分。

垃圾回收器：

- Serial收集器（复制算法）：新生代单线程收集器，简单高效。
- ParNew收集器（复制算法）：新生代并行收集器，Serial收集器的多线程版本。
- Parallel Scavenge收集器（复制算法）：新生代并行收集器，追求高吞吐，高效利用CPU。
- Serial Old收集器（标记-整理算法）：老年代单线程收集器。Serial收集器的老年代版本。
- Parallel New收集器（标记-整理算法）：老年代并行收集器，吞吐量优先。Parallel Scavenge收集器的老年代版本。
- CMS收集器（标记-清除算法）：老年代并行收集器，高并发低停顿。ParNew收集器的老年搭档。会产生浮动垃圾。浮动垃圾过多会退化。适用于低延迟，碎片化管理。
- G1收集器（标记-整理算法）：默认收集器覆盖整个Java堆。可以预测垃圾回收的停顿时间。合理利用了资源，最均衡。能充分利用CPU。

STW：

初始标记阶段，并发标记阶段，再标记阶段。

清理阶段。

复制阶段。

转移阶段（最久）。

## GC的分类

Minor GC：

只针对年轻代。包括Eden区和S0S1区。

触发条件：当Eden区空间不足时，进行相对移动。通常很频繁。如果多次存活会一直移动到老年代。

Major GC：

主要针对老年代。

触发条件：老年代空间不足或者检测晋升速度过快时。频率低，存活量高。

Full GC：

针对整个堆内存

触发条件：

- 直接调用方法
- 老年代空间不足
- 元空间空间不足

# JUC

JUC通常指`java.util.concurrent`包

## 线程池

线程池是为了减少频繁的创建线程和销毁线程带来的性能损耗。

线程池分为核心线程池，线程池的最大容量，还有等待任务的队列。

提交一个任务，如果核心线程没有满，就创建一个线程，如果满了，就是会加入等待队列，如果等待队列满了，就会增加线程，如果达到最大线程数量，如果都达到最大线程数量，就会按照一些丢弃的策略进行处理。

```text
提交任务 → 核心线程是否已满？
  ├─ 未满 → 创建核心线程执行
  └─ 已满 → 任务入队
       ├─ 队列未满 → 等待执行
       └─ 队列已满 → 创建非核心线程
           ├─ 未达最大线程数 → 执行任务
           └─ 已达最大线程数 → 执行拒绝策略
```

```java
new ThreadPoolExecutor(
    16,                     // corePoolSize = 16（假设8核CPU × 2）
    32,                     // maximumPoolSize = 32（突发流量扩容）
    10, TimeUnit.SECONDS,   // 非核心线程空闲10秒回收
    new SynchronousQueue<>(), // 不缓存任务，直接扩容线程
    Executors.defaultThreadFactory(),//线程工厂。用于创建新线程。
    new AbortPolicy()       // 直接拒绝，避免系统过载
);
```

线程池的构造函数有7个参数：

- **corePoolSize**：线程池核心线程数量。默认情况下，线程池中线程的数量如果 <= corePoolSize，那么即使这些线程处于空闲状态，那也不会被销毁。
- **maximumPoolSize**：线程池中最多可容纳的线程数量。当一个新任务交给线程池，如果此时线程池中有空闲的线程，就会直接执行，如果没有空闲的线程且当前线程池的线程数量小于maximumPoolSize，就会创建新的线程来执行任务，否则就会将该任务加入到阻塞队列中，如果阻塞队列满了，就会创建一个新线程，从阻塞队列头部取出一个任务来执行，并将新任务加入到阻塞队列末尾。如果当前线程池中线程的数量等于maximumPoolSize，就不会创建新线程，就会去执行拒绝策略。
- **keepAliveTime**：当线程池中线程的数量大于corePoolSize，并且某个线程的空闲时间超过了keepAliveTime，那么这个线程就会被销毁。
- **unit**：就是keepAliveTime时间的单位。
- **workQueue**：工作队列。当没有空闲的线程执行新任务时，该任务就会被放入工作队列中，等待执行。
- **threadFactory**：线程工厂。可以用来给线程取名字等等
- **handler**：拒绝策略。当一个新任务交给线程池，如果此时线程池中有空闲的线程，就会直接执行，如果没有空闲的线程，就会将该任务加入到阻塞队列中，如果阻塞队列满了，就会创建一个新线程，从阻塞队列头部取出一个任务来执行，并将新任务加入到阻塞队列末尾。如果当前线程池中线程的数量等于maximumPoolSize，就不会创建新线程，就会去执行拒绝策略。

线程池有五种状态：

1. running

线程池正常运行 既能接受新任务 也会处理队列中的任务

2. shutdown

调用线程池的shutdown()方法 线程池进入shutdown状态 不会接受新任务 但是会完成队列中的任务

3. stop

调用线程池的shutdownnow()方法 线程池进入stop状态 不会接受新任务 也不会完成队列中的任务 正在运行的线程也会被中断

4. tidying

没有线程运行的状态 线程池内部会调用terminated() 这个是空方法 可以自定义

5. terminated

terminated()方法调用后线程池状态

线程池种类：

- ScheduledThreadPool：可以设置定期的执行任务，它支持定时或周期性执行任务，比如每隔 10 秒钟执行一次任务，我通过这个实现类设置定期执行任务的策略。
- FixedThreadPool：它的核心线程数和最大线程数是一样的，所以可以把它看作是固定线程数的线程池，它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。
- CachedThreadPool：可以称作可缓存线程池，它的特点在于线程数是几乎可以无限增加的（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1，这个数非常大，所以基本不可能达到），而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。
- SingleThreadExecutor：它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。
- SingleThreadScheduledExecutor：它实际和 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程。

线程池的`shutDown()`和`shutDownNow()`:

- shutdown使用了以后会置状态为SHUTDOWN，正在执行的任务会继续执行下去，没有被执行的则中断。此时，则不能再往线程池中添加任何任务，否则将会抛出 RejectedExecutionException 异常
- 而 shutdownNow 为STOP，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。 它试图终止线程的方法是通过调用 Thread.interrupt() 方法来实现的，但是这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。